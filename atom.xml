<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>龙龙的网站</title>
  
  
  <link href="https://longsizhuo123.github.io/atom.xml" rel="self"/>
  
  <link href="https://longsizhuo123.github.io/"/>
  <updated>2023-09-26T16:24:39.799Z</updated>
  <id>https://longsizhuo123.github.io/</id>
  
  <author>
    <name>long long</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2582.递枕头</title>
    <link href="https://longsizhuo123.github.io/post/82e09f92.html"/>
    <id>https://longsizhuo123.github.io/post/82e09f92.html</id>
    <published>2023-09-26T14:00:00.000Z</published>
    <updated>2023-09-26T16:24:39.799Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h1><p><img src="../assets/img/%E6%88%AA%E5%B1%8F2023-09-27%20%E4%B8%8A%E5%8D%882.19.52.png" alt="截屏2023-09-27 上午2.19.52.png"></p><p><a href="https://leetcode-cn.com/problems/di-zhen-tou/">2582.递枕头.md</a></p><h1 id="思想："><a href="#思想：" class="headerlink" title="思想："></a>思想：</h1><p>数学题，找规律，n个人，间隔=n-1，在人群中的循环次数= $time // (n-1)$，循环次数为2的倍数则从头往后数，否则从后往前数。</p><p><img src="../assets/img/%E6%88%AA%E5%B1%8F2023-09-27%20%E4%B8%8A%E5%8D%882.24.10.png" alt="截屏2023-09-27 上午2.24.10.png"></p><h1 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">passThePillow</span>(<span class="params">self, n: <span class="built_in">int</span>, time: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> n &gt; time:</span><br><span class="line">            <span class="keyword">return</span> time + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> time // (n-<span class="number">1</span>) % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> time % (n-<span class="number">1</span>) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> n - time % (n-<span class="number">1</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目：&quot;&gt;&lt;a href=&quot;#题目：&quot; class=&quot;headerlink&quot; title=&quot;题目：&quot;&gt;&lt;/a&gt;题目：&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;../assets/img/%E6%88%AA%E5%B1%8F2023-09-27%20%E4%B8%8A%E</summary>
      
    
    
    
    
    <category term="Python" scheme="https://longsizhuo123.github.io/tags/Python/"/>
    
    <category term="题解" scheme="https://longsizhuo123.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="数学" scheme="https://longsizhuo123.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="模拟" scheme="https://longsizhuo123.github.io/tags/%E6%A8%A1%E6%8B%9F/"/>
    
  </entry>
  
  <entry>
    <title>146.LRU 缓存</title>
    <link href="https://longsizhuo123.github.io/post/b9130c0e.html"/>
    <id>https://longsizhuo123.github.io/post/b9130c0e.html</id>
    <published>2023-09-24T14:00:00.000Z</published>
    <updated>2023-09-24T15:27:31.156Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h1><p>第一次遇见：’2023/3/14-15:21’<br><img src="../assets/img/%E6%88%AA%E5%B1%8F2023-09-25%20%E4%B8%8A%E5%8D%881.14.08.png" alt="截屏2023-09-25 上午1.14.08.png"></p><p><a href="https://leetcode-cn.com/problems/lru-cache/">146.LRU 缓存.md</a></p><h1 id="思想："><a href="#思想：" class="headerlink" title="思想："></a>思想：</h1><p>简单的模拟，用字典就做出来了，好像完全没用到双向链表和LRU的思想。。。我有罪，依稀能记得半年前吹着空调做的。<br>题解就看代码的注释应该就能看懂，不懂的留言我会回复。</p><h1 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, capacity: <span class="built_in">int</span></span>):</span><br><span class="line">        self.capacity = capacity</span><br><span class="line">        self.cache = collections.OrderedDict()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self, key: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 如果key在字典中，返回value</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self.cache:</span><br><span class="line">            self.cache.move_to_end(key)</span><br><span class="line">            <span class="keyword">return</span> self.cache[key]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 如果key不在字典中，返回-1</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">put</span>(<span class="params">self, key: <span class="built_in">int</span>, value: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self.cache:</span><br><span class="line">            <span class="comment"># 如果key在字典中，更新value</span></span><br><span class="line">            self.cache.move_to_end(key)</span><br><span class="line">            self.cache[key] = value</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(self.cache) == self.capacity:</span><br><span class="line">                <span class="comment"># 如果key不在字典中，且字典已满，删除最近最少使用的元素</span></span><br><span class="line">                self.cache.popitem(last=<span class="literal">False</span>)</span><br><span class="line">            <span class="comment"># 如果key不在字典中，且字典未满，添加元素</span></span><br><span class="line">            <span class="comment"># self.cache.move_to_end(key)</span></span><br><span class="line">            self.cache[key] = value</span><br></pre></td></tr></table></figure><h1 id="第二种解法"><a href="#第二种解法" class="headerlink" title="第二种解法"></a>第二种解法</h1><p><img src="../assets/img/%E6%88%AA%E5%B1%8F2023-09-25%20%E4%B8%8A%E5%8D%881.25.22.png" alt="截屏2023-09-25 上午1.25.22.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>:</span><br><span class="line">    <span class="comment"># 提高访问属性的速度，并节省内存</span></span><br><span class="line">    __slots__ = <span class="string">&#x27;prev&#x27;</span>, <span class="string">&#x27;next&#x27;</span>, <span class="string">&#x27;key&#x27;</span>, <span class="string">&#x27;value&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, key=<span class="number">0</span>, value=<span class="number">0</span></span>):</span><br><span class="line">        self.key = key</span><br><span class="line">        self.value = value</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, capacity: <span class="built_in">int</span></span>):</span><br><span class="line">        self.capacity = capacity</span><br><span class="line">        self.dummy = Node()  <span class="comment"># 哨兵节点</span></span><br><span class="line">        self.dummy.prev = self.dummy</span><br><span class="line">        self.dummy.<span class="built_in">next</span> = self.dummy</span><br><span class="line">        self.key_to_node = <span class="built_in">dict</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_node</span>(<span class="params">self, key: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[Node]:</span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> self.key_to_node:  <span class="comment"># 没有这本书</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        node = self.key_to_node[key]  <span class="comment"># 有这本书</span></span><br><span class="line">        self.remove(node)  <span class="comment"># 把这本书抽出来</span></span><br><span class="line">        self.push_front(node)  <span class="comment"># 放在最上面</span></span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self, key: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        node = self.get_node(key)</span><br><span class="line">        <span class="keyword">return</span> node.value <span class="keyword">if</span> node <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">put</span>(<span class="params">self, key: <span class="built_in">int</span>, value: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        node = self.get_node(key)</span><br><span class="line">        <span class="keyword">if</span> node:  <span class="comment"># 有这本书</span></span><br><span class="line">            node.value = value  <span class="comment"># 更新 value</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.key_to_node[key] = node = Node(key, value)  <span class="comment"># 新书</span></span><br><span class="line">        self.push_front(node)  <span class="comment"># 放在最上面</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.key_to_node) &gt; self.capacity:  <span class="comment"># 书太多了</span></span><br><span class="line">            back_node = self.dummy.prev</span><br><span class="line">            <span class="keyword">del</span> self.key_to_node[back_node.key]</span><br><span class="line">            self.remove(back_node)  <span class="comment"># 去掉最后一本书</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 删除一个节点（抽出一本书）</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">remove</span>(<span class="params">self, x: Node</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        x.prev.<span class="built_in">next</span> = x.<span class="built_in">next</span></span><br><span class="line">        x.<span class="built_in">next</span>.prev = x.prev</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 在链表头添加一个节点（把一本书放在最上面）</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push_front</span>(<span class="params">self, x: Node</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        x.prev = self.dummy</span><br><span class="line">        x.<span class="built_in">next</span> = self.dummy.<span class="built_in">next</span></span><br><span class="line">        x.prev.<span class="built_in">next</span> = x</span><br><span class="line">        x.<span class="built_in">next</span>.prev = x</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目：&quot;&gt;&lt;a href=&quot;#题目：&quot; class=&quot;headerlink&quot; title=&quot;题目：&quot;&gt;&lt;/a&gt;题目：&lt;/h1&gt;&lt;p&gt;第一次遇见：’2023/3/14-15:21’&lt;br&gt;&lt;img src=&quot;../assets/img/%E6%88%AA%E5%B1</summary>
      
    
    
    
    
    <category term="Python" scheme="https://longsizhuo123.github.io/tags/Python/"/>
    
    <category term="题解" scheme="https://longsizhuo123.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="哈希表" scheme="https://longsizhuo123.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
    <category term="链表" scheme="https://longsizhuo123.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
    <category term="设计" scheme="https://longsizhuo123.github.io/tags/%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="双向链表" scheme="https://longsizhuo123.github.io/tags/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>6323. 将钱分给最多的儿童</title>
    <link href="https://longsizhuo123.github.io/post/b9130c0e.html"/>
    <id>https://longsizhuo123.github.io/post/b9130c0e.html</id>
    <published>2023-09-22T13:00:00.000Z</published>
    <updated>2023-09-24T15:13:14.946Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h1><p>第一次遇见：’2023/3/19-16:51’<br><img src="../assets/img/%E6%88%AA%E5%B1%8F2023-09-22%20%E4%B8%8B%E5%8D%8811.42.18.png" alt="截屏2023-09-22 下午11.42.18.png"><br><a href="https://leetcode.cn/problems/distribute-money-to-maximum-children/">6323. 将钱分给最多的儿童.md</a></p><h1 id="思想："><a href="#思想：" class="headerlink" title="思想："></a>思想：</h1><p>“————–”</p><p>这道题是上半年3月份的时候的周赛题目，题目链接：6323</p><p>“————–”</p><p>一开始就发现了这个是数学题，奈何写了半天不知道怎么处理最后剩下的钱。<br>于是写了一个列表，一个孩子一个孩子地给钱。<br>数学：<br>如果剩余 0 人，且 money&gt;0，那么必须分给一个已经分到 8 美元的人，<br>ans 减一。<br>如果剩余 1 人，且 money=3，为避免分配 4 美元，<br>那么必须分给一个已经分到 8 美元的人，ans 减一。<br>其它情况全部给一个人，如果这个人分配到 4 美元，<br>他再给另一个人 1 美元，这样 ans 不变。</p><p>以下为ylb大佬的解释：（2023-9-22更新）<br>如果 money&lt;children，那么一定存在儿童没有分到钱，返回 −1。</p><p>如果 money&gt;8×children，那么有 children−1 个儿童获得了 8 美元，剩下的一个儿童获得了 money−8×(children−1) 美元，返回 children−1。</p><p>如果 money=8×children−4，那么有 children−2 个儿童获得了 8 美元，剩下的两个儿童分摊剩下的 12 美元（只要不是 4, 8 美元就行），返回 children−2。</p><p>如果，我们假设有 x 个儿童获得了 8 美元，那么剩下的钱为 money−8×x，只要保证大于等于剩下的儿童数 children−x，就可以满足题意。因此，我们只需要求出 x 的最大值，即为答案。</p><h1 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h1><figure class="highlight python"><figcaption><span>列表</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">distMoney</span>(<span class="params">self, money: <span class="built_in">int</span>, children: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        money -= children</span><br><span class="line">        children_list = [<span class="number">1</span>] * children</span><br><span class="line">        <span class="keyword">if</span> money &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        counts = <span class="built_in">min</span>(money // <span class="number">7</span>, children)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(counts):</span><br><span class="line">            children_list[i] = <span class="number">8</span></span><br><span class="line">        children_list[-<span class="number">1</span>] += money - counts * <span class="number">7</span></span><br><span class="line">        counts = children_list.count(<span class="number">8</span>)</span><br><span class="line">        <span class="keyword">if</span> children_list[-<span class="number">1</span>] == <span class="number">4</span>:</span><br><span class="line">            <span class="keyword">if</span> children_list[-<span class="number">2</span>] != <span class="number">8</span>:</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                counts -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> counts</span><br></pre></td></tr></table></figure><figure class="highlight python"><figcaption><span>数学</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">distMoney</span>(<span class="params">self, money: <span class="built_in">int</span>, children: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        money -= children  <span class="comment"># 每人至少 1 美元</span></span><br><span class="line">        <span class="keyword">if</span> money &lt; <span class="number">0</span>: <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        ans = <span class="built_in">min</span>(money // <span class="number">7</span>, children)  <span class="comment"># 初步分配，让尽量多的人分到 8 美元</span></span><br><span class="line">        money -= ans * <span class="number">7</span></span><br><span class="line">        children -= ans</span><br><span class="line">        <span class="comment"># children == 0 and money：必须找一个前面分了 8 美元的人，分配完剩余的钱</span></span><br><span class="line">        <span class="comment"># children == 1 and money == 3：不能有人恰好分到 4 美元</span></span><br><span class="line">        <span class="keyword">if</span> children == <span class="number">0</span> <span class="keyword">and</span> money <span class="keyword">or</span> \</span><br><span class="line">           children == <span class="number">1</span> <span class="keyword">and</span> money == <span class="number">3</span>:</span><br><span class="line">            ans -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><figure class="highlight python"><figcaption><span>ylb</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">distMoney</span>(<span class="params">self, money: <span class="built_in">int</span>, children: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> money &lt; children:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> money &gt; <span class="number">8</span> * children:</span><br><span class="line">            <span class="keyword">return</span> children - <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> money == <span class="number">8</span> * children - <span class="number">4</span>:</span><br><span class="line">            <span class="keyword">return</span> children - <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> (money-children) // <span class="number">7</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目：&quot;&gt;&lt;a href=&quot;#题目：&quot; class=&quot;headerlink&quot; title=&quot;题目：&quot;&gt;&lt;/a&gt;题目：&lt;/h1&gt;&lt;p&gt;第一次遇见：’2023/3/19-16:51’&lt;br&gt;&lt;img src=&quot;../assets/img/%E6%88%AA%E5%B1</summary>
      
    
    
    
    
    <category term="Python" scheme="https://longsizhuo123.github.io/tags/Python/"/>
    
    <category term="题解" scheme="https://longsizhuo123.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>2591.将钱分给最多的儿童</title>
    <link href="https://longsizhuo123.github.io/post/6a9ab144.html"/>
    <id>https://longsizhuo123.github.io/post/6a9ab144.html</id>
    <published>2023-09-22T13:00:00.000Z</published>
    <updated>2023-09-22T13:58:05.487Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h1><p><img src="../assets/img/%E6%88%AA%E5%B1%8F2023-09-22%20%E4%B8%8B%E5%8D%8811.42.18.png" alt="截屏2023-09-22 下午11.42.18.png"><br><a href="https://leetcode-cn.com/problems/divide-money-to-k-people/">题目链接</a></p><h1 id="思想："><a href="#思想：" class="headerlink" title="思想："></a>思想：</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目：&quot;&gt;&lt;a href=&quot;#题目：&quot; class=&quot;headerlink&quot; title=&quot;题目：&quot;&gt;&lt;/a&gt;题目：&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;../assets/img/%E6%88%AA%E5%B1%8F2023-09-22%20%E4%B8%8B%E</summary>
      
    
    
    
    
    <category term="Python" scheme="https://longsizhuo123.github.io/tags/Python/"/>
    
    <category term="题解" scheme="https://longsizhuo123.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="数学" scheme="https://longsizhuo123.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="贪心" scheme="https://longsizhuo123.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>LCP 06.拿硬币</title>
    <link href="https://longsizhuo123.github.io/post/66079b7b.html"/>
    <id>https://longsizhuo123.github.io/post/66079b7b.html</id>
    <published>2023-09-20T14:00:00.000Z</published>
    <updated>2023-09-20T14:15:49.446Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h1><p><img src="../assets/img/%E6%88%AA%E5%B1%8F2023-09-21%20%E4%B8%8A%E5%8D%8812.12.09.png" alt="截屏2023-09-21 上午12.12.09.png"><br><a href="https://leetcode-cn.com/problems/na-ying-bi/">题目链接</a></p><h1 id="思想："><a href="#思想：" class="headerlink" title="思想："></a>思想：</h1><p>既然4需要两次，3也需要两次，那么说明这道题无非就是“尽量2个2个取，取不完的就计数+1”<br>虽然感觉还能在运行时间上再优化，但是我更喜欢写一行</p><h1 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minCount</span>(<span class="params">self, coins: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(i // <span class="number">2</span> + i % <span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> coins)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目：&quot;&gt;&lt;a href=&quot;#题目：&quot; class=&quot;headerlink&quot; title=&quot;题目：&quot;&gt;&lt;/a&gt;题目：&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;../assets/img/%E6%88%AA%E5%B1%8F2023-09-21%20%E4%B8%8A%E</summary>
      
    
    
    
    
    <category term="Python" scheme="https://longsizhuo123.github.io/tags/Python/"/>
    
    <category term="题解" scheme="https://longsizhuo123.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="数学" scheme="https://longsizhuo123.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="数组" scheme="https://longsizhuo123.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>213.打家劫舍 III</title>
    <link href="https://longsizhuo123.github.io/post/86590614.html"/>
    <id>https://longsizhuo123.github.io/post/86590614.html</id>
    <published>2023-09-18T03:00:00.000Z</published>
    <updated>2023-09-18T03:15:57.245Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h1><p><img src="../assets/img/%E6%88%AA%E5%B1%8F2023-09-18%20%E4%B8%8B%E5%8D%881.08.41.png" alt="截屏2023-09-18 下午1.08.41.png"><br><a href="https://leetcode-cn.com/problems/house-robber-iii/">题目链接</a></p><h1 id="思想："><a href="#思想：" class="headerlink" title="思想："></a>思想：</h1><p>参考了 ylb 大佬的题解，<br>这道题和打家劫舍1和2的区别在于，这道题是一棵二叉树，而且不能打劫相邻的节点。<br>所以他的最小子问题是：打劫了当前节点，就不能打劫自己的左右孩子。<br>如果偷取 root 节点，那么不能偷取其左右子节点，结果为 <code>root.val+lb +rb</code>；<br>如果不偷取 root 节点，那么可以偷取其左右子节点，结果为 <code>max(la, lb)+max(ra ,rb)</code>。</p><h1 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rob</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">_rob</span>(<span class="params">root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; (<span class="built_in">int</span>, <span class="built_in">int</span>):</span><br><span class="line">            <span class="comment"># 最小子问题:dp[i]=dp[i-2]+nums[i], dp[i-1]</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">            la, lb = _rob(root.left)</span><br><span class="line">            ra, rb = _rob(root.right)</span><br><span class="line">            <span class="keyword">return</span> root.val + lb + rb, <span class="built_in">max</span>(la, lb) + <span class="built_in">max</span>(ra, rb)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(_rob(root))</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目：&quot;&gt;&lt;a href=&quot;#题目：&quot; class=&quot;headerlink&quot; title=&quot;题目：&quot;&gt;&lt;/a&gt;题目：&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;../assets/img/%E6%88%AA%E5%B1%8F2023-09-18%20%E4%B8%8B%E</summary>
      
    
    
    
    
    <category term="Python" scheme="https://longsizhuo123.github.io/tags/Python/"/>
    
    <category term="题解" scheme="https://longsizhuo123.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="动态规划" scheme="https://longsizhuo123.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="二叉树" scheme="https://longsizhuo123.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    <category term="深度优先搜索" scheme="https://longsizhuo123.github.io/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
    <category term="树" scheme="https://longsizhuo123.github.io/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>213.打家劫舍 II</title>
    <link href="https://longsizhuo123.github.io/post/85beb0bf.html"/>
    <id>https://longsizhuo123.github.io/post/85beb0bf.html</id>
    <published>2023-09-17T14:00:00.000Z</published>
    <updated>2023-09-17T16:35:40.131Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h1><p><img src="../assets/img/%E6%88%AA%E5%B1%8F2023-09-18%20%E4%B8%8A%E5%8D%882.31.30.png" alt="截屏2023-09-18 上午2.31.30.png"><br><a href="https://leetcode-cn.com/problems/house-robber-ii/">题目链接</a></p><h1 id="思想："><a href="#思想：" class="headerlink" title="思想："></a>思想：</h1><p>这一次终于懂一点动态规划了，首先是最小子问题，我一开始认为是考虑从哪里开始，是从第一个还是第二个开始（这刚好是和打家劫舍1的区别）。<br>但实际上最小子问题还是和打家劫舍1一样：是否打劫当前房子。<br>首先我们设置一个<code>dp</code>数组，<code>dp[i]</code>表示打劫到第<code>i</code>个房子时的最大收益。<br>那么我们打劫当前房子后 <code>dp[i] = dp[i-2] + nums[i]</code>，(因为打劫了当前房子就不能打劫之前的房子)，不打劫当前房子 <code>dp[i] = dp[i-1]</code>。<br>所以我们可以得到状态转移方程：<code>dp[i] = max(dp[i-2] + nums[i], dp[i-1])</code>。<br>最后分类讨论打劫第一个还是第二个开始就行。</p><h1 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rob</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">rob1</span>(<span class="params">nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">            ans = <span class="number">0</span></span><br><span class="line">            dp = [<span class="number">0</span>] * <span class="built_in">len</span>(nums)</span><br><span class="line">            <span class="comment"># def: dp[i]表示打劫第i家的最大收益</span></span><br><span class="line">            <span class="comment"># 偷窃 第i家房屋，则收益为dp[i-2]+nums[i], 不偷窃第i家房屋，则收益为dp[i-1]</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">                dp[i] = <span class="built_in">max</span>(dp[i - <span class="number">2</span>] + nums[i], dp[i - <span class="number">1</span>])</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, dp[i])</span><br><span class="line">            <span class="keyword">return</span> ans</span><br><span class="line">        <span class="comment"># 打劫第一家，或者第二家开始</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(rob1(nums[:-<span class="number">1</span>]), rob1(nums[<span class="number">1</span>:])) <span class="keyword">if</span> <span class="built_in">len</span>(nums) != <span class="number">1</span> <span class="keyword">else</span> nums[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目：&quot;&gt;&lt;a href=&quot;#题目：&quot; class=&quot;headerlink&quot; title=&quot;题目：&quot;&gt;&lt;/a&gt;题目：&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;../assets/img/%E6%88%AA%E5%B1%8F2023-09-18%20%E4%B8%8A%E</summary>
      
    
    
    
    
    <category term="Python" scheme="https://longsizhuo123.github.io/tags/Python/"/>
    
    <category term="题解" scheme="https://longsizhuo123.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="动态规划" scheme="https://longsizhuo123.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="数组" scheme="https://longsizhuo123.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>LCP 50.宝石补给</title>
    <link href="https://longsizhuo123.github.io/post/762ca698.html"/>
    <id>https://longsizhuo123.github.io/post/762ca698.html</id>
    <published>2023-09-15T04:12:00.000Z</published>
    <updated>2023-09-15T06:31:10.104Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h1><p><img src="../assets/img/%E6%88%AA%E5%B1%8F2023-09-15%20%E4%B8%8B%E5%8D%882.23.12.png" alt="截屏2023-09-15 下午2.23.12.png"><br><a href="https://leetcode.cn/problems/bao-zi-fen-shu/">题目链接</a></p><h1 id="思想："><a href="#思想：" class="headerlink" title="思想："></a>思想：</h1><p>LCP开头居然是新手村的意思，简单的模拟，遍历operations，对gem进行加减计算。</p><h1 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">giveGem</span>(<span class="params">self, gem: <span class="type">List</span>[<span class="built_in">int</span>], operations: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">for</span> i, j <span class="keyword">in</span> operations:</span><br><span class="line">            trade = gem[i] // <span class="number">2</span></span><br><span class="line">            gem[i] -= trade</span><br><span class="line">            gem[j] += trade</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(gem)-<span class="built_in">min</span>(gem)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目：&quot;&gt;&lt;a href=&quot;#题目：&quot; class=&quot;headerlink&quot; title=&quot;题目：&quot;&gt;&lt;/a&gt;题目：&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;../assets/img/%E6%88%AA%E5%B1%8F2023-09-15%20%E4%B8%8B%E</summary>
      
    
    
    
    
    <category term="Python" scheme="https://longsizhuo123.github.io/tags/Python/"/>
    
    <category term="题解" scheme="https://longsizhuo123.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="数组" scheme="https://longsizhuo123.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="模拟" scheme="https://longsizhuo123.github.io/tags/%E6%A8%A1%E6%8B%9F/"/>
    
  </entry>
  
  <entry>
    <title>1222.可以攻击国王的皇后</title>
    <link href="https://longsizhuo123.github.io/post/a6577367.html"/>
    <id>https://longsizhuo123.github.io/post/a6577367.html</id>
    <published>2023-09-14T13:12:00.000Z</published>
    <updated>2023-09-14T14:26:44.647Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h1><p><img src="../assets/img/%E6%88%AA%E5%B1%8F2023-09-15%20%E4%B8%8A%E5%8D%8812.10.07.png" alt="截屏2023-09-15 上午12.10.07.png"><br><a href="https://leetcode-cn.com/problems/queens-that-can-attack-the-king/">题目链接</a></p><h1 id="思想："><a href="#思想：" class="headerlink" title="思想："></a>思想：</h1><p>直接模拟，分别判断横向，纵向，对角线上的皇后是否存在，如果存在，就记录下来，最后返回。</p><p>答案的方法和我的类似，但是更加简洁，从国王往外走，记录碰到的第一个皇后。</p><h1 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h1><figure class="highlight python"><figcaption><span>我流</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">queensAttacktheKing</span>(<span class="params">self, queens: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], king: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        x = king[<span class="number">0</span>]</span><br><span class="line">        y = king[<span class="number">1</span>]</span><br><span class="line">        x_left_diff = <span class="number">64</span></span><br><span class="line">        x_right_diff = <span class="number">64</span></span><br><span class="line">        left_high_diff = <span class="number">64</span></span><br><span class="line">        left_low_diff = <span class="number">64</span></span><br><span class="line">        right_high_diff = <span class="number">64</span></span><br><span class="line">        right_low_diff = <span class="number">64</span></span><br><span class="line">        y_left_diff = <span class="number">64</span></span><br><span class="line">        y_right_diff = <span class="number">64</span></span><br><span class="line">        res = [[]] * <span class="number">8</span></span><br><span class="line">        <span class="built_in">print</span>(res)</span><br><span class="line">        <span class="keyword">for</span> i, j <span class="keyword">in</span> queens:</span><br><span class="line">            <span class="comment"># 横向</span></span><br><span class="line">            <span class="keyword">if</span> i == x:</span><br><span class="line">                <span class="keyword">if</span> j &lt; y <span class="keyword">and</span> <span class="built_in">abs</span>(j - y) &lt; x_left_diff:</span><br><span class="line">                    res[<span class="number">0</span>] = [i, j]</span><br><span class="line">                    x_left_diff = <span class="built_in">abs</span>(j - y)</span><br><span class="line">                <span class="keyword">elif</span> j &gt; y <span class="keyword">and</span> <span class="built_in">abs</span>(j - y) &lt; x_right_diff:</span><br><span class="line">                    res[<span class="number">1</span>] = [i, j]</span><br><span class="line">                    x_right_diff = <span class="built_in">abs</span>(j - y)</span><br><span class="line">            <span class="comment"># 纵向</span></span><br><span class="line">            <span class="keyword">elif</span> j == y:</span><br><span class="line">                <span class="keyword">if</span> i &lt; x <span class="keyword">and</span> <span class="built_in">abs</span>(i - x) &lt; y_left_diff:</span><br><span class="line">                    res[<span class="number">6</span>] = [i, j]</span><br><span class="line">                    y_left_diff = <span class="built_in">abs</span>(i - x)</span><br><span class="line">                <span class="keyword">elif</span> i &gt; x <span class="keyword">and</span> <span class="built_in">abs</span>(i - x) &lt; y_right_diff:</span><br><span class="line">                    res[<span class="number">7</span>] = [i, j]</span><br><span class="line">                    y_right_diff = <span class="built_in">abs</span>(i - x)</span><br><span class="line">            <span class="comment"># 对角线上</span></span><br><span class="line">            <span class="keyword">elif</span> <span class="built_in">abs</span>(i - x) == <span class="built_in">abs</span>(j - y):</span><br><span class="line">                <span class="keyword">if</span> i &lt; x <span class="keyword">and</span> j &lt; y <span class="keyword">and</span> <span class="built_in">abs</span>(i - x) &lt; left_high_diff:</span><br><span class="line">                    res[<span class="number">2</span>] = [i, j]</span><br><span class="line">                    left_high_diff = <span class="built_in">abs</span>(i - x)</span><br><span class="line">                <span class="keyword">elif</span> i &lt; x <span class="keyword">and</span> j &gt; y <span class="keyword">and</span> <span class="built_in">abs</span>(i - x) &lt; left_low_diff:</span><br><span class="line">                    res[<span class="number">3</span>] = [i, j]</span><br><span class="line">                    left_low_diff = <span class="built_in">abs</span>(i - x)</span><br><span class="line">                <span class="keyword">elif</span> i &gt; x <span class="keyword">and</span> j &lt; y <span class="keyword">and</span> <span class="built_in">abs</span>(i - x) &lt; right_high_diff:</span><br><span class="line">                    res[<span class="number">4</span>] = [i, j]</span><br><span class="line">                    right_high_diff = <span class="built_in">abs</span>(i - x)</span><br><span class="line">                <span class="keyword">elif</span> i &gt; x <span class="keyword">and</span> j &gt; y <span class="keyword">and</span> <span class="built_in">abs</span>(i - x) &lt; right_low_diff:</span><br><span class="line">                    res[<span class="number">5</span>] = [i, j]</span><br><span class="line">                    right_low_diff = <span class="built_in">abs</span>(i - x)</span><br><span class="line">        <span class="keyword">return</span> [i <span class="keyword">for</span> i <span class="keyword">in</span> res <span class="keyword">if</span> i != []]</span><br></pre></td></tr></table></figure><figure class="highlight python"><figcaption><span>答案</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">queensAttacktheKing</span>(<span class="params">self, queens: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], king: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        s = <span class="built_in">set</span>(<span class="built_in">map</span>(<span class="built_in">tuple</span>, queens))</span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">for</span> dx, dy <span class="keyword">in</span> (<span class="number">1</span>, <span class="number">0</span>), (<span class="number">1</span>, <span class="number">1</span>), (<span class="number">0</span>, <span class="number">1</span>), (-<span class="number">1</span>, <span class="number">1</span>), (-<span class="number">1</span>, <span class="number">0</span>), (-<span class="number">1</span>, -<span class="number">1</span>), (<span class="number">0</span>, -<span class="number">1</span>), (<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            x, y = king[<span class="number">0</span>] + dx, king[<span class="number">1</span>] + dy</span><br><span class="line">            <span class="keyword">while</span> <span class="number">0</span> &lt;= x &lt; <span class="number">8</span> <span class="keyword">and</span> <span class="number">0</span> &lt;= y &lt; <span class="number">8</span>:</span><br><span class="line">                <span class="keyword">if</span> (x, y) <span class="keyword">in</span> s:</span><br><span class="line">                    ans.append([x, y])</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                x += dx</span><br><span class="line">                y += dy</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目：&quot;&gt;&lt;a href=&quot;#题目：&quot; class=&quot;headerlink&quot; title=&quot;题目：&quot;&gt;&lt;/a&gt;题目：&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;../assets/img/%E6%88%AA%E5%B1%8F2023-09-15%20%E4%B8%8A%E</summary>
      
    
    
    
    
    <category term="Python" scheme="https://longsizhuo123.github.io/tags/Python/"/>
    
    <category term="题解" scheme="https://longsizhuo123.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="数组" scheme="https://longsizhuo123.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="矩阵" scheme="https://longsizhuo123.github.io/tags/%E7%9F%A9%E9%98%B5/"/>
    
    <category term="模拟" scheme="https://longsizhuo123.github.io/tags/%E6%A8%A1%E6%8B%9F/"/>
    
  </entry>
  
  <entry>
    <title>2596.检查骑士巡逻方案</title>
    <link href="https://longsizhuo123.github.io/post/29546b92.html"/>
    <id>https://longsizhuo123.github.io/post/29546b92.html</id>
    <published>2023-09-13T07:12:00.000Z</published>
    <updated>2023-09-13T07:56:56.102Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h1><p><img src="../assets/img/%E6%88%AA%E5%B1%8F2023-09-13%20%E4%B8%8B%E5%8D%885.14.07.png" alt="截屏2023-09-13 下午5.14.07.png"><br><a href="https://leetcode.cn/problems/check-knight-tour-configuration/description/?envType=daily-question&envId=2023-09-13">题目链接</a></p><h1 id="思想："><a href="#思想：" class="headerlink" title="思想："></a>思想：</h1><p>第一眼以为是 N皇后 问题，然后读了半天没读懂题，所以去看了一眼答案（）。<br>原来<code>grid[row][col] 表示单元格 (row, col) 是骑士访问的第 grid[row][col] 个单元格。</code>的意思是<code>pos[grid[i][j]] = (i, j)</code><br>然后这下就懂了，设置个初始值（2，1），然后从（0，0）开始遍历每个点与<code>last</code>的值的差值是否是2，1或者1，2，如果不是，就返回False。</p><pre><code>在答案中，ylb用的是pairwise的方法计算前后两个元素for (x1, y1), (x2, y2) in pairwise(pos): dx, dy = abs(x1 - x2), abs(y1 - y2)</code></pre><h1 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">checkValidGrid</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> grid[<span class="number">0</span>][<span class="number">0</span>]:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        n = <span class="built_in">len</span>(grid)</span><br><span class="line">        pos = [(<span class="number">0</span>, <span class="number">0</span>)] * (n * n)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                pos[grid[i][j]] = (i, j)</span><br><span class="line">        last = -<span class="number">2</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i, j <span class="keyword">in</span> pos:</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">abs</span>(i - last[<span class="number">0</span>]) == <span class="number">2</span> <span class="keyword">and</span> <span class="built_in">abs</span>(j - last[<span class="number">1</span>]) == <span class="number">1</span>) <span class="keyword">or</span> \</span><br><span class="line">                    (<span class="built_in">abs</span>(i - last[<span class="number">0</span>]) == <span class="number">1</span> <span class="keyword">and</span> <span class="built_in">abs</span>(j - last[<span class="number">1</span>]) == <span class="number">2</span>):</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(i, j)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            last = (i, j)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目：&quot;&gt;&lt;a href=&quot;#题目：&quot; class=&quot;headerlink&quot; title=&quot;题目：&quot;&gt;&lt;/a&gt;题目：&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;../assets/img/%E6%88%AA%E5%B1%8F2023-09-13%20%E4%B8%8B%E</summary>
      
    
    
    
    
    <category term="Python" scheme="https://longsizhuo123.github.io/tags/Python/"/>
    
    <category term="题解" scheme="https://longsizhuo123.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="数组" scheme="https://longsizhuo123.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="矩阵" scheme="https://longsizhuo123.github.io/tags/%E7%9F%A9%E9%98%B5/"/>
    
    <category term="模拟" scheme="https://longsizhuo123.github.io/tags/%E6%A8%A1%E6%8B%9F/"/>
    
    <category term="深度优先搜索" scheme="https://longsizhuo123.github.io/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
    <category term="广度优先搜索" scheme="https://longsizhuo123.github.io/tags/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>1462.课程表IV</title>
    <link href="https://longsizhuo123.github.io/post/5f312ae.html"/>
    <id>https://longsizhuo123.github.io/post/5f312ae.html</id>
    <published>2023-09-12T09:57:00.000Z</published>
    <updated>2023-09-12T13:03:25.296Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h1><p><img src="../assets/img/img_2.png" alt="img_2.png"></p><p><a href="https://leetcode.cn/problems/course-schedule-iv/?envType=daily-question&envId=2023-09-12">[1460]课程表IV.md</a></p><h1 id="思想："><a href="#思想：" class="headerlink" title="思想："></a>思想：</h1><p>一开始的想法是构建有向图，然后在有向图中找到query的两个点是否有父子关系。<br>但看了ylb的答案后，发现先计算出可达性更快。<br>首先遍历prerequirements，将所有的可达性记录下来。<br>然后三重循环，连接所有的可达性。</p><pre><code>i-&gt;j-&gt;k，如果i-&gt;k，那么i-&gt;k就是可达的。</code></pre><h1 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">checkIfPrerequisite</span>(<span class="params">self, n: <span class="built_in">int</span>, prerequisites: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], queries: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[</span><br><span class="line">        <span class="built_in">bool</span>]:</span><br><span class="line">        f = [[<span class="literal">False</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        <span class="keyword">for</span> a, b <span class="keyword">in</span> prerequisites:</span><br><span class="line">            f[a][b] = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                    f[i][j] = f[i][j] <span class="keyword">or</span> (f[i][k] <span class="keyword">and</span> f[k][j])</span><br><span class="line">        <span class="keyword">return</span> [f[a][b] <span class="keyword">for</span> a, b <span class="keyword">in</span> queries]</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目：&quot;&gt;&lt;a href=&quot;#题目：&quot; class=&quot;headerlink&quot; title=&quot;题目：&quot;&gt;&lt;/a&gt;题目：&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;../assets/img/img_2.png&quot; alt=&quot;img_2.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href</summary>
      
    
    
    
    
    <category term="Python" scheme="https://longsizhuo123.github.io/tags/Python/"/>
    
    <category term="题解" scheme="https://longsizhuo123.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="深度优先搜索" scheme="https://longsizhuo123.github.io/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
    <category term="广度优先搜索" scheme="https://longsizhuo123.github.io/tags/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
    <category term="图" scheme="https://longsizhuo123.github.io/tags/%E5%9B%BE/"/>
    
    <category term="拓扑排序" scheme="https://longsizhuo123.github.io/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>630.课程表III</title>
    <link href="https://longsizhuo123.github.io/post/e14241e.html"/>
    <id>https://longsizhuo123.github.io/post/e14241e.html</id>
    <published>2023-09-11T16:25:00.000Z</published>
    <updated>2023-09-11T15:45:19.495Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h1><p><img src="../assets/img/img_1.png" alt="img_1.png"></p><p><a href="https://leetcode.cn/problems/course-schedule-iii/">题目链接</a></p><h1 id="思想："><a href="#思想：" class="headerlink" title="思想："></a>思想：</h1><p>思路来自于宫水三叶的贪心 + 优先队列，</p><ol><li>首先，我们按课程的结束时间对它们进行排序。这样做的目的是尝试每个课程，看看它能否适应我们的时间表。</li><li>因为Python的heapq默认是一个最小堆，所以当我们加入一个课程时，我们使用其持续时间的负数，从而使得堆顶部始终是持续时间最长的课程。</li><li>当遍历每个课程时，尝试把它加入到我们的日程中。但是，如果我们发现加入该课程后总时间超过了该课程的结束时间，那么我们需要从我们的日程中去掉一个课程，最好去掉那个持续时间最长的课程，因为这将释放出最多的时间，这也是为什么使用一个最大堆。<br><code>sum += heapq.heappop(q)</code></li><li>Java中的<code>Arrays.sort(courses, (a,b)-&gt;a[1]-b[1]); </code>等同于Python中的<code>courses.sort(key=lambda x: x[1])</code></li></ol><p>以下引用宫水三叶解法原文，关于为什么使用greedy：</p><pre><code>题目是要我们构造出一种可行的排列，排列中每个课程的实际结束时间满足「最晚完成时间」要求，求可行排序的最大长度（每个课程对答案的贡献都是 1）。这容易引导我们往「泛化背包」方面进行思考：简单来说，对于某个物品（课程）而言，在不同条件下成本不同，在时间轴 `[1,courses[i][1]−courses[i][0]]` 上该物品可被选，成本为其持续时间，在比该范围大的数轴上无法被选，成本为正无穷。因此某一段特定的时间轴上，问题可抽象成有条件限制的组合优化问题。由于数据范围为 10^4，泛化背包做法需要记录的维度大于一维，不予考虑。再然后容易想到「二分」，显然在以最大选择数量 ans 为分割点的数组上具有「二段性」：1. 使用数量小于等于 ans 的课程能够构造出合法排序（考虑在最长合法序列上做减法即可）；2. 使用数量大于 ans 的课程无法构造出合法排列。此时二分范围为 `[0,n]`，问题转化为：如何在 `O(n)` 检查是否可构造出某个长度 len 的合法排列（实现 `check` 方法）。常规的线性扫描做法无法确定是否存在某个长度的合法排列，因此二分不予考虑。我们需要运用「贪心」思维考虑可能的方案。</code></pre><h1 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">scheduleCourse</span>(<span class="params">self, courses: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        courses.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># This will be a max-heap based on course duration</span></span><br><span class="line">        q = []</span><br><span class="line">        <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> courses:</span><br><span class="line">            d, e = c</span><br><span class="line">            <span class="built_in">sum</span> += d</span><br><span class="line">            heapq.heappush(q, -d)</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">sum</span> &gt; e:</span><br><span class="line">                <span class="built_in">sum</span> += heapq.heappop(q)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(q)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目：&quot;&gt;&lt;a href=&quot;#题目：&quot; class=&quot;headerlink&quot; title=&quot;题目：&quot;&gt;&lt;/a&gt;题目：&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;../assets/img/img_1.png&quot; alt=&quot;img_1.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href</summary>
      
    
    
    
    
    <category term="Python" scheme="https://longsizhuo123.github.io/tags/Python/"/>
    
    <category term="题解" scheme="https://longsizhuo123.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="贪心" scheme="https://longsizhuo123.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
    <category term="优先队列" scheme="https://longsizhuo123.github.io/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>GO语言# GO语言可爱捏</title>
    <link href="https://longsizhuo123.github.io/post/67fc8613.html"/>
    <id>https://longsizhuo123.github.io/post/67fc8613.html</id>
    <published>2023-07-27T08:03:55.611Z</published>
    <updated>2023-07-27T08:03:55.611Z</updated>
    
    <content type="html"><![CDATA[<p><img src="../assets/img/motorcycle.svg" alt="motorcycle.svg"></p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Hello world&quot;</span>)</span><br><span class="line">arr := []<span class="type">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line">fmt.Println(a(arr))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">a</span><span class="params">(x []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(x); i++ &#123;</span><br><span class="line"><span class="keyword">if</span> i%<span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">x[i] = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight golang"><figcaption><span>修改字符串</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="string">&quot;hello&quot;</span></span><br><span class="line">c := []<span class="type">byte</span>(s)  <span class="comment">// 将字符串 s 转换为 []byte 类型</span></span><br><span class="line">c[<span class="number">0</span>] = <span class="string">&#x27;c&#x27;</span></span><br><span class="line">s2 := <span class="type">string</span>(c)  <span class="comment">// 再转换回 string 类型</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, s2)</span><br><span class="line"></span><br><span class="line">s := <span class="string">&quot;hello&quot;</span></span><br><span class="line">s = <span class="string">&quot;c&quot;</span> + s[<span class="number">1</span>:] <span class="comment">// 字符串虽不能更改，但可进行切片操作</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, s)</span><br></pre></td></tr></table></figure><p>如果要声明一个多行的字符串怎么办？可以通过`来声明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">m := `hello</span><br><span class="line">world`</span><br></pre></td></tr></table></figure><p>` 括起的字符串为Raw字符串，即字符串在代码中的形式就是打印时的形式，它没有字符转义，换行也将原样输出</p><h1 id="错误类型"><a href="#错误类型" class="headerlink" title="错误类型"></a>错误类型</h1><p>Go内置有一个error类型，专门用来处理错误信息，Go的package里面还专门有一个包errors来处理错误：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">err := errors.New(<span class="string">&quot;emit macho dwarf: elf header corrupted&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Print(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;../assets/img/motorcycle.svg&quot; alt=&quot;motorcycle.svg&quot;&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight golang&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;sp</summary>
      
    
    
    
    
    <category term="Python" scheme="https://longsizhuo123.github.io/tags/Python/"/>
    
    <category term="题解" scheme="https://longsizhuo123.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>置顶文章</title>
    <link href="https://longsizhuo123.github.io/post/edc2b94.html"/>
    <id>https://longsizhuo123.github.io/post/edc2b94.html</id>
    <published>2023-07-27T08:03:55.611Z</published>
    <updated>2023-07-27T08:03:55.611Z</updated>
    
    <content type="html"><![CDATA[<h1 id="longsizhuo123-github-io"><a href="#longsizhuo123-github-io" class="headerlink" title="longsizhuo123.github.io"></a>longsizhuo123.github.io</h1><p><img src="https://user-images.githubusercontent.com/114939201/214082770-35d1fb45-9891-4b73-ba89-18e33030640f.png" alt="pattern_stripes-1_1_2_0-0_125_1__cc2a35_4f372d_00a1b0_edc951_eb6941"></p><p><em>“Maybe it could be a nice memory”</em></p><p>Welcome to my personal blog repository on Github! My name is Sizhuo Long, and I am currently a student in Australia. This repository is home to my personal blog, which is built using the HEXO static site generator. </p><p>On my blog, you’ll find a variety of content including my thoughts on technology, programming, and the latest developments in my field of study. I also share my experiences and lessons learned from the projects I’ve worked on. </p><p>I hope that by sharing my knowledge and insights, I can help others who are interested in the same topics. I welcome any comments and feedback, and I am always open to collaboration. </p><p><strong>Thank you for visiting my blog</strong>, I hope you will find something interesting here. And I would really appreciate it if you could pay more attention to my blog and <strong>follow me</strong>.</p><h3 id="Why-you-should-follow-me"><a href="#Why-you-should-follow-me" class="headerlink" title="Why you should follow me"></a>Why you should follow me</h3><ul><li>I’ll share my personal experiences and thoughts on technology and programming </li><li>I’ll keep you updated on the latest developments in my field of study</li><li>I’m open to collaboration and feedback.</li></ul><h3 id="How-to-contact-me"><a href="#How-to-contact-me" class="headerlink" title="How to contact me"></a>How to contact me</h3><ul><li>Email: <a href="mailto:&#x6c;&#x6f;&#x6e;&#x67;&#x73;&#105;&#x7a;&#104;&#x75;&#x6f;&#64;&#103;&#109;&#x61;&#105;&#x6c;&#46;&#99;&#x6f;&#109;">&#x6c;&#x6f;&#x6e;&#x67;&#x73;&#105;&#x7a;&#104;&#x75;&#x6f;&#64;&#103;&#109;&#x61;&#105;&#x6c;&#46;&#99;&#x6f;&#109;</a></li><li>LinkedIn: <a href="https://www.linkedin.com/in/longsizhuo/">Sizhuo Long</a></li><li>XiaoHongShu(Small RedBook): <a href="https://www.xiaohongshu.com/user/profile/5c0b8cc2000000000601e809">@sizhuo_long</a></li></ul><p>Thank you for reading, and I hope you enjoy my blog!</p><p><img src="https://user-images.githubusercontent.com/114939201/214082782-ae84027e-0a15-4ed4-843b-00a29ea19480.png" alt="pattern_stripes-1_1_2_0-0_125_1__cc2a35_4f372d_00a1b0_edc951_eb6941"></p><p><strong><a href="https://longsizhuo.shinyapps.io/long/">面向单细胞RNA数据分析工具</a></strong><br>以前做的项目，还有很多错误，勿喷。<br><strong><a href="html/Sichuan_Traveler/index.html">蜀地旅行菌</a></strong><br>这是一个本科大二的时候的一个小作业，是小组作业。一开始因为链接不了<code>html</code>文件，阅读了很多很多官方文档或者CSDN文档<br>    。最后阅读了一篇文章，说是HEXO在当你<code>generate</code>的时候，就会把source中的文件append到public中去，后来试了很多次，发现直接以<br>public为源文件夹，调用目录即可。虽然这样就会导致无法在md文档中超链接到文件。    </p><p>同时，也存在新的bug未解决：login.html无法和index.html相互跳转<br>Linkin:</p><div class="badge-base LI-profile-badge" data-locale="zh_CN" data-size="medium" data-theme="dark" data-type="HORIZONTAL" data-vanity="longsizhuo" data-version="v1"><a class="badge-base__link LI-simple-link" href="https://au.linkedin.com/in/longsizhuo?trk=profile-badge">Sizhuo Long</a></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;longsizhuo123-github-io&quot;&gt;&lt;a href=&quot;#longsizhuo123-github-io&quot; class=&quot;headerlink&quot; title=&quot;longsizhuo123.github.io&quot;&gt;&lt;/a&gt;longsizhuo123.git</summary>
      
    
    
    
    <category term="前端" scheme="https://longsizhuo123.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="HEXO" scheme="https://longsizhuo123.github.io/categories/%E5%89%8D%E7%AB%AF/HEXO/"/>
    
    <category term="未解决" scheme="https://longsizhuo123.github.io/categories/%E6%9C%AA%E8%A7%A3%E5%86%B3/"/>
    
    <category term="存在bug" scheme="https://longsizhuo123.github.io/categories/%E6%9C%AA%E8%A7%A3%E5%86%B3/%E5%AD%98%E5%9C%A8bug/"/>
    
    
    <category term="未解决" scheme="https://longsizhuo123.github.io/tags/%E6%9C%AA%E8%A7%A3%E5%86%B3/"/>
    
    <category term="前端" scheme="https://longsizhuo123.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>2679.矩阵中的和</title>
    <link href="https://longsizhuo123.github.io/post/5277100.html"/>
    <id>https://longsizhuo123.github.io/post/5277100.html</id>
    <published>2023-07-04T14:27:00.000Z</published>
    <updated>2023-07-27T08:03:55.609Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h1><p><img src="../assets/img/2023-07-05.png" alt="2023-07-05.png"><br><a href="https://leetcode.cn/problems/sum-in-a-matrix/">2679.矩阵中的和.md</a></p><h1 id="思想："><a href="#思想：" class="headerlink" title="思想："></a>思想：</h1><p><strong>一行</strong><br>首先题意是找到每个子列表中最大的那个数，然后把pop出去，最后求和。<br>一次次遍历效果太差，于是我想到了用zip一次性遍历多个子数组。<br>于是先对每个子数组排序，然后用zip遍历，找到最大值。<br>举个例子：<br><code>nums = [[7,2,1],[6,4,2],[6,5,3],[3,2,1]]</code><br>排序后：<br><code>nums = [[1,2,7],[2,4,6],[3,5,6],[1,2,3]]</code><br>然后用zip遍历得到：<br><code>[(1,2,3,1),(2,4,5,2),(7,6,6,3)]</code><br>找最大值：<br><code>[3,5,7]</code><br>求和：<br><code>15</code></p><h1 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">matrixSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(<span class="built_in">max</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> \</span><br><span class="line">        <span class="built_in">zip</span>(*(<span class="built_in">sorted</span>(sublist) <span class="keyword">for</span> sublist <span class="keyword">in</span> nums)))</span><br></pre></td></tr></table></figure><h3 id="的作用以及zip-讲解"><a href="#的作用以及zip-讲解" class="headerlink" title="*的作用以及zip()讲解"></a>*的作用以及zip()讲解</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">nums = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">7</span>],[<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>],[<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums[<span class="number">1</span>])):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">        <span class="built_in">print</span>(nums[j][i])</span><br><span class="line"><span class="comment"># ans = 123124527663</span></span><br><span class="line">num1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">7</span>]</span><br><span class="line">num2 = [<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>]</span><br><span class="line">num3 = [<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">num4 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure><p><code>zip()</code>函数是将多个列表中的元素一一对应，然后返回一个zip对象，可以用list()函数转换为列表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">zip</span>(num1, num2, num3, num4):</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line"><span class="comment">#(1, 2, 3, 1)</span></span><br><span class="line"><span class="comment">#(2, 4, 5, 2)</span></span><br><span class="line"><span class="comment">#(7, 6, 6, 3)</span></span><br></pre></td></tr></table></figure><p><code>*nums</code>的作用在python中不是指针，而是将nums中的每个元素作为参数传入函数中。我在这里理解为列举。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 列举</span></span><br><span class="line"><span class="built_in">print</span>(*nums)</span><br><span class="line"><span class="comment"># [1, 2, 7] [2, 4, 6] [3, 5, 6] [1, 2, 3]</span></span><br></pre></td></tr></table></figure><p><code>zip(*nums)</code>是将nums中的每个元素作为参数传入zip()函数中，然后返回一个zip对象，可以用list()函数转换为列表。<br><code>zip(*nums)</code>等价于<code>zip(num1, num2, num3, num4)</code>，其中num1, num2, num3, num4是nums中的元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">zip</span>(*nums):</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line"><span class="comment"># 等效</span></span><br><span class="line"><span class="comment">#(1, 2, 3, 1)</span></span><br><span class="line"><span class="comment">#(2, 4, 5, 2)</span></span><br><span class="line"><span class="comment">#(7, 6, 6, 3)</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目：&quot;&gt;&lt;a href=&quot;#题目：&quot; class=&quot;headerlink&quot; title=&quot;题目：&quot;&gt;&lt;/a&gt;题目：&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;../assets/img/2023-07-05.png&quot; alt=&quot;2023-07-05.png&quot;&gt;&lt;br&gt;&lt;</summary>
      
    
    
    
    
    <category term="Python" scheme="https://longsizhuo123.github.io/tags/Python/"/>
    
    <category term="题解" scheme="https://longsizhuo123.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="数组" scheme="https://longsizhuo123.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="矩阵" scheme="https://longsizhuo123.github.io/tags/%E7%9F%A9%E9%98%B5/"/>
    
    <category term="排序" scheme="https://longsizhuo123.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
    <category term="模拟" scheme="https://longsizhuo123.github.io/tags/%E6%A8%A1%E6%8B%9F/"/>
    
    <category term="堆（优先队列）" scheme="https://longsizhuo123.github.io/tags/%E5%A0%86%EF%BC%88%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%EF%BC%89/"/>
    
  </entry>
  
  <entry>
    <title>445.两数相加II</title>
    <link href="https://longsizhuo123.github.io/post/2c4cc46c.html"/>
    <id>https://longsizhuo123.github.io/post/2c4cc46c.html</id>
    <published>2023-07-02T17:40:00.000Z</published>
    <updated>2023-07-27T08:03:55.609Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h1><p><img src="../assets/img/2023-07-03%20(1).png" alt="2023-07-03 (1).png"><br><a href="https://leetcode.cn/problems/add-two-numbers-ii/">445.两数相加</a></p><h1 id="思想："><a href="#思想：" class="headerlink" title="思想："></a>思想：</h1><p>跟昨天的题一已，顺便找到了<br>    力扣要的是一个很奇怪的<code>precompiled.listnode.ListNode</code>，但是我的是<code>&#39;__main__.ListNode&#39;</code>。<br>原因是：重复定义了$ListNode$<br>不反转链表的方法可能就是昨天的那种，转化为数学做。<br>代码依旧是<a href="https://leetcode.cn/problems/add-two-numbers-ii/solution/fan-zhuan-lian-biao-liang-shu-xiang-jia-okw6q/">0x3f的</a><br>与昨天的题解法一样</p><h1 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseList</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="keyword">if</span> head <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> head.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        new_head = self.reverseList(head.<span class="built_in">next</span>)</span><br><span class="line">        head.<span class="built_in">next</span>.<span class="built_in">next</span> = head  <span class="comment"># 把下一个节点指向自己</span></span><br><span class="line">        head.<span class="built_in">next</span> = <span class="literal">None</span>  <span class="comment"># 断开指向下一个节点的连接，保证最终链表的末尾节点的 next 是空节点</span></span><br><span class="line">        <span class="keyword">return</span> new_head</span><br><span class="line"></span><br><span class="line">    <span class="comment"># l1 和 l2 为当前遍历的节点，carry 为进位</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">addTwo</span>(<span class="params">self, l1: <span class="type">Optional</span>[ListNode], l2: <span class="type">Optional</span>[ListNode], carry=<span class="number">0</span></span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="keyword">if</span> l1 <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> l2 <span class="keyword">is</span> <span class="literal">None</span>:  <span class="comment"># 递归边界：l1 和 l2 都是空节点</span></span><br><span class="line">            <span class="keyword">return</span> ListNode(carry) <span class="keyword">if</span> carry <span class="keyword">else</span> <span class="literal">None</span>  <span class="comment"># 如果进位了，就额外创建一个节点</span></span><br><span class="line">        <span class="keyword">if</span> l1 <span class="keyword">is</span> <span class="literal">None</span>:  <span class="comment"># 如果 l1 是空的，那么此时 l2 一定不是空节点</span></span><br><span class="line">            l1, l2 = l2, l1  <span class="comment"># 交换 l1 与 l2，保证 l1 非空，从而简化代码</span></span><br><span class="line">        carry += l1.val + (l2.val <span class="keyword">if</span> l2 <span class="keyword">else</span> <span class="number">0</span>)  <span class="comment"># 节点值和进位加在一起</span></span><br><span class="line">        l1.val = carry % <span class="number">10</span>  <span class="comment"># 每个节点保存一个数位</span></span><br><span class="line">        l1.<span class="built_in">next</span> = self.addTwo(l1.<span class="built_in">next</span>, l2.<span class="built_in">next</span> <span class="keyword">if</span> l2 <span class="keyword">else</span> <span class="literal">None</span>, carry // <span class="number">10</span>)  <span class="comment"># 进位</span></span><br><span class="line">        <span class="keyword">return</span> l1</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">addTwoNumbers</span>(<span class="params">self, l1: <span class="type">Optional</span>[ListNode], l2: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        l1 = self.reverseList(l1)</span><br><span class="line">        l2 = self.reverseList(l2)  <span class="comment"># l1 和 l2 反转后，就变成【2. 两数相加】了</span></span><br><span class="line">        l3 = self.addTwo(l1, l2)</span><br><span class="line">        <span class="keyword">return</span> self.reverseList(l3)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目：&quot;&gt;&lt;a href=&quot;#题目：&quot; class=&quot;headerlink&quot; title=&quot;题目：&quot;&gt;&lt;/a&gt;题目：&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;../assets/img/2023-07-03%20(1).png&quot; alt=&quot;2023-07-03 (1).</summary>
      
    
    
    
    
    <category term="Python" scheme="https://longsizhuo123.github.io/tags/Python/"/>
    
    <category term="题解" scheme="https://longsizhuo123.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="数学" scheme="https://longsizhuo123.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="链表" scheme="https://longsizhuo123.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
    <category term="递归" scheme="https://longsizhuo123.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
    <category term="栈" scheme="https://longsizhuo123.github.io/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>2 .两数相加</title>
    <link href="https://longsizhuo123.github.io/post/fa9db6b8.html"/>
    <id>https://longsizhuo123.github.io/post/fa9db6b8.html</id>
    <published>2023-07-02T13:19:00.000Z</published>
    <updated>2023-07-27T08:03:55.611Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h1><p><img src="../assets/img/2023-07-03.png" alt="2023-07-03.png"><br><a href="https://leetcode.cn/problems/add-two-numbers/">[2].两数相加.md</a></p><h1 id="思想："><a href="#思想：" class="headerlink" title="思想："></a>思想：</h1><p>我本来写的是最蠢的方法，把两个链表转换成数字，然后相加，再转换成链表。但是很奇怪的是我在本地运行的时候是对的，但是提交的时候就不对了，<br>力扣要的是一个很奇怪的<code>precompiled.listnode.ListNode</code>，但是我的是<code>&#39;__main__.ListNode&#39;</code>。<br>所以只能看<a href="https://leetcode.cn/problems/add-two-numbers/solution/dong-hua-jian-ji-xie-fa-cong-di-gui-dao-oe0di/">0x3f</a>的答案。</p><pre><code>每次把两个节点值`l1.val`，`l2.val`与进位值`carry`相加，除以 10 的余数即为当前节点需要保存的数位，除以10的商即为新的进位值</code></pre><p>代码实现时，有一个简化代码的小技巧：如果递归中发现<code>l2</code>的长度比<code>l1</code>更长，那么可以交换<code>l1</code>和 <code>l2</code>，保证 <code>l1</code>不是空节点，从而简化代码逻辑。</p><h1 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="comment"># l1 和 l2 为当前遍历的节点，carry 为进位</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">addTwoNumbers</span>(<span class="params">self, l1: <span class="type">Optional</span>[ListNode], l2: <span class="type">Optional</span>[ListNode], carry=<span class="number">0</span></span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="keyword">if</span> l1 <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> l2 <span class="keyword">is</span> <span class="literal">None</span>:  <span class="comment"># 递归边界：l1 和 l2 都是空节点</span></span><br><span class="line">            <span class="keyword">return</span> ListNode(carry) <span class="keyword">if</span> carry <span class="keyword">else</span> <span class="literal">None</span>  <span class="comment"># 如果进位了，就额外创建一个节点</span></span><br><span class="line">        <span class="keyword">if</span> l1 <span class="keyword">is</span> <span class="literal">None</span>:  <span class="comment"># 如果 l1 是空的，那么此时 l2 一定不是空节点</span></span><br><span class="line">            l1, l2 = l2, l1  <span class="comment"># 交换 l1 与 l2，保证 l1 非空，从而简化代码</span></span><br><span class="line">        carry += l1.val + (l2.val <span class="keyword">if</span> l2 <span class="keyword">else</span> <span class="number">0</span>)  <span class="comment"># 节点值和进位加在一起</span></span><br><span class="line">        l1.val = carry % <span class="number">10</span>  <span class="comment"># 每个节点保存一个数位</span></span><br><span class="line">        l1.<span class="built_in">next</span> = self.addTwoNumbers(l1.<span class="built_in">next</span>, l2.<span class="built_in">next</span> <span class="keyword">if</span> l2 <span class="keyword">else</span> <span class="literal">None</span>, carry // <span class="number">10</span>)  <span class="comment"># 进位</span></span><br><span class="line">        <span class="keyword">return</span> l1</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">addTwoNumbers</span>(<span class="params">self, l1: <span class="type">Optional</span>[ListNode], l2: <span class="type">Optional</span>[ListNode], carry = <span class="number">0</span></span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        l1_list = []</span><br><span class="line">        l2_list=[]</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">recursion_list</span>(<span class="params">node:ListNode, listt</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">                <span class="keyword">return</span> listt</span><br><span class="line">            listt.append(node.val)</span><br><span class="line">            <span class="keyword">return</span> recursion_list(node.<span class="built_in">next</span>, listt)</span><br><span class="line">        l1_list = recursion_list(l1, l1_list)</span><br><span class="line">        l2_list = recursion_list(l2, l2_list)</span><br><span class="line">        l1_list = <span class="string">&#x27;&#x27;</span>.join(<span class="built_in">map</span>(<span class="built_in">str</span>, l1_list))</span><br><span class="line">        l2_list = <span class="string">&#x27;&#x27;</span>.join(<span class="built_in">map</span>(<span class="built_in">str</span>, l2_list))</span><br><span class="line">        l3 = <span class="built_in">str</span>(<span class="built_in">int</span>(l1_list)+<span class="built_in">int</span>(l2_list))</span><br><span class="line">        <span class="built_in">print</span>(l3)</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">recursion_linkArray</span>(<span class="params">num</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> num:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            head = ListNode(<span class="number">0</span>)</span><br><span class="line">            current = head</span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> num:</span><br><span class="line">                current.<span class="built_in">next</span> = ListNode(<span class="built_in">int</span>(c))</span><br><span class="line">                current = current.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">return</span> head.<span class="built_in">next</span></span><br><span class="line">        head = recursion_linkArray(l3[::-<span class="number">1</span>])</span><br><span class="line">        <span class="built_in">print</span>(recursion_list(head, []))</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">type</span>(l1), <span class="built_in">type</span>(head))</span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目：&quot;&gt;&lt;a href=&quot;#题目：&quot; class=&quot;headerlink&quot; title=&quot;题目：&quot;&gt;&lt;/a&gt;题目：&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;../assets/img/2023-07-03.png&quot; alt=&quot;2023-07-03.png&quot;&gt;&lt;br&gt;&lt;</summary>
      
    
    
    
    
    <category term="Python" scheme="https://longsizhuo123.github.io/tags/Python/"/>
    
    <category term="题解" scheme="https://longsizhuo123.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="数学" scheme="https://longsizhuo123.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="链表" scheme="https://longsizhuo123.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
    <category term="递归" scheme="https://longsizhuo123.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>2490回环句</title>
    <link href="https://longsizhuo123.github.io/post/5c07686c.html"/>
    <id>https://longsizhuo123.github.io/post/5c07686c.html</id>
    <published>2023-06-30T15:57:00.000Z</published>
    <updated>2023-07-27T08:03:55.610Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h1><p><img src="../assets/img/2023-07-01.png" alt="2023-07-01.png"><br><a href="https://leetcode.cn/problems/circular-sentence/">[2490]回环句.md</a></p><h1 id="思想："><a href="#思想：" class="headerlink" title="思想："></a>思想：</h1><p>分割每个单词，然后拼接到一起（<code>123</code>拼接成<code>123123</code>），再直接判断每个单词对应的下一个单词是否满足首尾相同即可。</p><h1 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isCircularSentence</span>(<span class="params">self, sentence: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        sentence = sentence.split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        length = <span class="built_in">len</span>(sentence)</span><br><span class="line">        sentence += sentence</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, length):</span><br><span class="line">            <span class="keyword">if</span> sentence[i][-<span class="number">1</span>] != sentence[i+<span class="number">1</span>][<span class="number">0</span>]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目：&quot;&gt;&lt;a href=&quot;#题目：&quot; class=&quot;headerlink&quot; title=&quot;题目：&quot;&gt;&lt;/a&gt;题目：&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;../assets/img/2023-07-01.png&quot; alt=&quot;2023-07-01.png&quot;&gt;&lt;br&gt;&lt;</summary>
      
    
    
    
    
    <category term="Python" scheme="https://longsizhuo123.github.io/tags/Python/"/>
    
    <category term="题解" scheme="https://longsizhuo123.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="字符串" scheme="https://longsizhuo123.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>1253.重构 2 行二进制矩阵</title>
    <link href="https://longsizhuo123.github.io/post/5c98e66b.html"/>
    <id>https://longsizhuo123.github.io/post/5c98e66b.html</id>
    <published>2023-06-29T16:25:00.000Z</published>
    <updated>2023-07-27T08:03:55.610Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h1><p><a href="https://leetcode.cn/problems/reconstruct-a-2-row-binary-matrix/">[1253]重构 2 行二进制矩阵.md</a><br><img src="../assets/img/2023-06-30.png" alt="重构 2 行二进制矩阵"></p><h1 id="思想："><a href="#思想：" class="headerlink" title="思想："></a>思想：</h1><p>一开始又读错题了，以为是将<code>colsum</code>分成<code>upper</code> 和 <code>lower</code>两个数组，<br>结果是将将<code>colsum[i]</code>分成<code>upper[i]</code> 和 <code>lower[i]</code>两个数。<br>并且<code>upper[i]</code>和<code>lower[i]</code>的和等于<code>colsum[i]</code>。<br>在每一次的循环里，获取<code>colsum</code>的值，然后判断0，1，2仨种情况，0直接不管，2的话平均分配。<br>1的话，直接给当前最小的那个数组。（这里我用的<code>upper</code>和<code>lower</code>本身的参数来记录剩余数字）。<br>在最开始的时候判断<code>if sum(colsum) != upper + lower</code>， 最后判断<code>if upper + lower != 0</code>。</p><p>At first, I misunderstood the question again, thinking that it was about dividing <code>colsum</code> into two arrays, <code>upper</code> and <code>lower</code>. However, it turned out that it was about dividing <code>colsum[i]</code> into two numbers, <code>upper[i]</code> and <code>lower[i]</code>. Additionally, the sum of <code>upper[i]</code> and <code>lower[i]</code> should be equal to <code>colsum[i]</code>.<br>In each iteration, the value of <code>colsum</code> is obtained, and then three scenarios, 0, 1, and 2, are considered. If it’s 0, it is ignored. If it’s 2, the values are evenly distributed. If it’s 1, it is assigned to the array with the current minimum value (using the remaining numbers in upper and lower than parameters).<br>At the beginning, it is checked whether <code>if sum(colsum) != upper + lower</code>, and finally, it is checked whether <code>if upper + lower != 0</code>.</p><h1 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reconstructMatrix</span>(<span class="params">self, upper: <span class="built_in">int</span>, lower: <span class="built_in">int</span>, colsum: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">sum</span>(colsum) != upper + lower:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        upper_list = [<span class="number">0</span>] * <span class="built_in">len</span>(colsum)</span><br><span class="line">        lower_list = [<span class="number">0</span>] * <span class="built_in">len</span>(colsum)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(colsum)):</span><br><span class="line">            <span class="keyword">if</span> colsum[i] == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> colsum[i] == <span class="number">2</span>:</span><br><span class="line">                upper_list[i] = <span class="number">1</span></span><br><span class="line">                lower_list[i] = <span class="number">1</span></span><br><span class="line">                upper -= <span class="number">1</span></span><br><span class="line">                lower -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> upper &gt;= lower:</span><br><span class="line">                    upper_list[i] = <span class="number">1</span></span><br><span class="line">                    upper -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    lower_list[i] = <span class="number">1</span></span><br><span class="line">                    lower -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> upper != <span class="number">0</span> <span class="keyword">or</span> lower != <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">return</span> [upper_list, lower_list]</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目：&quot;&gt;&lt;a href=&quot;#题目：&quot; class=&quot;headerlink&quot; title=&quot;题目：&quot;&gt;&lt;/a&gt;题目：&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/reconstruct-a-2-row-binary-m</summary>
      
    
    
    
    
    <category term="Python" scheme="https://longsizhuo123.github.io/tags/Python/"/>
    
    <category term="题解" scheme="https://longsizhuo123.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="数组" scheme="https://longsizhuo123.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="矩阵" scheme="https://longsizhuo123.github.io/tags/%E7%9F%A9%E9%98%B5/"/>
    
    <category term="贪心" scheme="https://longsizhuo123.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
    <category term="中等" scheme="https://longsizhuo123.github.io/tags/%E4%B8%AD%E7%AD%89/"/>
    
  </entry>
  
  <entry>
    <title>538.把二叉搜索树转换为累加树</title>
    <link href="https://longsizhuo123.github.io/post/32401b69.html"/>
    <id>https://longsizhuo123.github.io/post/32401b69.html</id>
    <published>2023-06-04T08:50:00.000Z</published>
    <updated>2023-07-27T08:03:55.609Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h1><p>“””</p><p>给出二叉<strong> 搜索 </strong>树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 <code>node</code>&nbsp;的新值等于原树中大于或等于&nbsp;<code>node.val</code>&nbsp;的值之和。</p><p>提醒一下，二叉搜索树满足下列约束条件：</p><ul>  <li>节点的左子树仅包含键<strong> 小于 </strong>节点键的节点。</li>  <li>节点的右子树仅包含键<strong> 大于</strong> 节点键的节点。</li>  <li>左右子树也必须是二叉搜索树。</li> </ul><p><strong>注意：</strong>本题和 1038:&nbsp;<a href="https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/">https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/</a> 相同</p><p>&nbsp;</p><p><strong>示例 1：</strong></p><p><strong><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/05/03/tree.png" style="height: 364px; width: 534px;" /></strong></p><pre><strong>输入：</strong>[4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]<strong>输出：</strong>[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]</pre><p><strong>示例 2：</strong></p><pre><strong>输入：</strong>root = [0,null,1]<strong>输出：</strong>[1,null,1]</pre><p><strong>示例 3：</strong></p><pre><strong>输入：</strong>root = [1,0,2]<strong>输出：</strong>[3,3,2]</pre><p><strong>示例 4：</strong></p><pre><strong>输入：</strong>root = [3,2,4,1]<strong>输出：</strong>[7,9,4,10]</pre><p>&nbsp;</p><p><strong>提示：</strong></p><ul>  <li>树中的节点数介于 <code>0</code>&nbsp;和 <code>10<sup>4</sup></code><sup>&nbsp;</sup>之间。</li>  <li>每个节点的值介于 <code>-10<sup>4</sup></code>&nbsp;和&nbsp;<code>10<sup>4</sup></code>&nbsp;之间。</li>  <li>树中的所有值 <strong>互不相同</strong> 。</li>  <li>给定的树为二叉搜索树。</li> </ul><div><div>Related Topics</div><div><li>树</li><li>深度优先搜索</li><li>二叉搜索树</li><li>二叉树</li></div></div><br><div><li>👍 904</li><li>👎 0</li></div>"""<h1 id="思想："><a href="#思想：" class="headerlink" title="思想："></a>思想：</h1><p>方法一：反序中序遍历<br>思路及算法</p><p>本题中要求我们将每个节点的值修改为原来的节点值加上所有大于它的节点值之和。这样我们只需要反序中序遍历该二叉搜索树，记录过程中的节点值之和，并不断更新当前遍历到的节点的节点值，即可得到题目要求的累加树。</p><p>方法二：Morris 遍历<br>思路及算法</p><p>有一种巧妙的方法可以在线性时间内，只占用常数空间来实现中序遍历。这种方法由 J. H. Morris 在 1979 年的论文「Traversing Binary Trees Simply and Cheaply」中首次提出，因此被称为 Morris 遍历。</p><p>我们以一个简单的二叉树为例进行说明。假设我们要进行中序遍历的 Morris 遍历。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">    1</span></span><br><span class="line"><span class="code">   / \</span></span><br><span class="line"><span class="code">  2   3</span></span><br><span class="line"><span class="code"> / \</span></span><br><span class="line"><span class="code">4   5</span></span><br><span class="line"><span class="code"></span></span><br></pre></td></tr></table></figure><ol><li><p>初始化当前节点为根节点（current = 1）。</p></li><li><p>当前节点不为空时，执行以下步骤：</p><ol><li><p>当前节点的左子节点不为空。我们找到当前节点的前驱节点，也就是左子树中的最右节点。在这个例子中，前驱节点为节点5。</p></li><li><p>前驱节点的右子节点为空，将其右子节点指向当前节点（5 -&gt; 1）。</p></li><li><p>将当前节点移动到其左子节点（current = 2）。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line"> \</span><br><span class="line">  2</span><br><span class="line"> / \</span><br><span class="line">4   5</span><br></pre></td></tr></table></figure></li><li><p>当前节点的左子节点不为空。我们找到当前节点的前驱节点，也就是左子树中的最右节点。在这个例子中，前驱节点为节点4。</p></li><li><p>前驱节点的右子节点为空，将其右子节点指向当前节点（4 -&gt; 2）。</p></li><li><p>将当前节点移动到其左子节点（current = 4）。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line"> \</span><br><span class="line">  2</span><br><span class="line">   \</span><br><span class="line"><span class="code">    4</span></span><br><span class="line"><span class="code">     \</span></span><br><span class="line"><span class="code">      5</span></span><br><span class="line"><span class="code">    </span></span><br></pre></td></tr></table></figure></li><li><p>当前节点的左子节点为空。输出当前节点的值（4）。</p></li><li><p>将当前节点移动到其右子节点（current = 5）。</p></li><li><p>当前节点的左子节点为空。输出当前节点的值（5）。</p></li><li><p>将当前节点移动到其右子节点（current = 2）。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line"> \</span><br><span class="line">  2</span><br><span class="line">   \</span><br><span class="line"><span class="code">    4</span></span><br></pre></td></tr></table></figure></li><li><p>当前节点的左子节点为空。输出当前节点的值（2）。</p></li><li><p>将当前节点移动到其右子节点（current = 1）。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line"> \</span><br><span class="line">  2</span><br></pre></td></tr></table></figure></li><li><p>当前节点的左子节点为空。输出当前节点的值（1）。</p></li><li><p>将当前节点移动到其右子节点（current = 3）。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line"> \</span><br><span class="line">  2</span><br></pre></td></tr></table></figure></li><li><p>当前节点的左子节点为空。输出当前节点的值（3）。</p></li><li><p>将当前节点移动到其右子节点（current = null）。</p></li></ol></li><li><p>当前节点为空，遍历结束。</p></li><li><p>根据上述步骤，通过修改节点之间的指针关系，我们完成了对二叉树的中序遍历。</p></li></ol><h1 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h1><figure class="highlight python"><figcaption><span>中序遍历</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">convertBST</span>(<span class="params">self, root: TreeNode</span>) -&gt; TreeNode:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">root: TreeNode</span>):</span><br><span class="line">            <span class="keyword">nonlocal</span> total</span><br><span class="line">            <span class="keyword">if</span> root:</span><br><span class="line">                dfs(root.right)</span><br><span class="line">                total += root.val</span><br><span class="line">                root.val = total</span><br><span class="line">                dfs(root.left)</span><br><span class="line">        </span><br><span class="line">        total = <span class="number">0</span></span><br><span class="line">        dfs(root)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><figure class="highlight python"><figcaption><span>Morris遍历</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">convertBST</span>(<span class="params">self, root: TreeNode</span>) -&gt; TreeNode:</span><br><span class="line">        <span class="comment"># 获取给定节点的后继节点（中序遍历中的下一个节点）</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">getSuccessor</span>(<span class="params">node: TreeNode</span>) -&gt; TreeNode:</span><br><span class="line">            succ = node.right</span><br><span class="line">            <span class="keyword">while</span> succ.left <span class="keyword">and</span> succ.left != node:</span><br><span class="line">                succ = succ.left</span><br><span class="line">            <span class="keyword">return</span> succ</span><br><span class="line">        </span><br><span class="line">        total = <span class="number">0</span>  <span class="comment"># 记录累加的节点值之和</span></span><br><span class="line">        node = root  <span class="comment"># 当前节点初始化为根节点</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> node:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node.right:  <span class="comment"># 如果当前节点的右子节点为空</span></span><br><span class="line">                total += node.val  <span class="comment"># 将当前节点的值加到累加值中</span></span><br><span class="line">                node.val = total  <span class="comment"># 更新当前节点的值为累加值</span></span><br><span class="line">                node = node.left  <span class="comment"># 将当前节点移动到其左子节点</span></span><br><span class="line">            <span class="keyword">else</span>:  <span class="comment"># 如果当前节点的右子节点不为空</span></span><br><span class="line">                succ = getSuccessor(node)  <span class="comment"># 获取当前节点的后继节点</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> succ.left:  <span class="comment"># 如果后继节点的左子节点为空</span></span><br><span class="line">                    succ.left = node  <span class="comment"># 将后继节点的左子节点指向当前节点，建立线索</span></span><br><span class="line">                    node = node.right  <span class="comment"># 将当前节点移动到其右子节点</span></span><br><span class="line">                <span class="keyword">else</span>:  <span class="comment"># 如果后继节点的左子节点不为空</span></span><br><span class="line">                    succ.left = <span class="literal">None</span>  <span class="comment"># 将后继节点的左子节点置为空，移除线索</span></span><br><span class="line">                    total += node.val  <span class="comment"># 将当前节点的值加到累加值中</span></span><br><span class="line">                    node.val = total  <span class="comment"># 更新当前节点的值为累加值</span></span><br><span class="line">                    node = node.left  <span class="comment"># 将当前节点移动到其左子节点</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root  <span class="comment"># 返回根节点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">convertBST</span>(<span class="params">self, root: TreeNode</span>) -&gt; TreeNode:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">convert</span>(<span class="params">node: TreeNode, total: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">                <span class="keyword">return</span> total</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 递归遍历右子树</span></span><br><span class="line">            total = convert(node.right, total)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 更新节点值为累加值</span></span><br><span class="line">            total += node.val</span><br><span class="line">            node.val = total</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 递归遍历左子树</span></span><br><span class="line">            total = convert(node.left, total)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> total</span><br><span class="line"></span><br><span class="line">        convert(root, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目：&quot;&gt;&lt;a href=&quot;#题目：&quot; class=&quot;headerlink&quot; title=&quot;题目：&quot;&gt;&lt;/a&gt;题目：&lt;/h1&gt;&lt;p&gt;“””&lt;/p&gt;
&lt;p&gt;给出二叉&lt;strong&gt; 搜索 &lt;/strong&gt;树的根节点，该树的节点值各不相同，请你将其转换为累加树（Gr</summary>
      
    
    
    
    
    <category term="Python" scheme="https://longsizhuo123.github.io/tags/Python/"/>
    
    <category term="题解" scheme="https://longsizhuo123.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="二叉树" scheme="https://longsizhuo123.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
</feed>
