<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>龙龙的网站</title>
  
  
  <link href="https://longsizhuo123.github.io/atom.xml" rel="self"/>
  
  <link href="https://longsizhuo123.github.io/"/>
  <updated>2023-10-08T12:36:26.372Z</updated>
  <id>https://longsizhuo123.github.io/</id>
  
  <author>
    <name>long long</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Inline expansion</title>
    <link href="https://longsizhuo123.github.io/post/2660e935.html"/>
    <id>https://longsizhuo123.github.io/post/2660e935.html</id>
    <published>2023-10-08T10:23:00.000Z</published>
    <updated>2023-10-08T12:36:26.372Z</updated>
    
    <content type="html"><![CDATA[<p>9021大家已经在卷运行时间了，这刚好就是$算法$发展的本质。</p><p><img src="../assets/img/%E6%88%AA%E5%B1%8F2023-10-08%20%E4%B8%8B%E5%8D%8811.35.38.png" alt="截屏2023-10-08 下午11.35.38.png"></p><p>“有一堆函数的代码和没有函数调用的代码，哪个运行的更快？”</p><p>我们先说结论：没有函数调用的代码运行的更快。但是<em><strong>可读性</strong></em>更差，而且<em><strong>运行速度的差距并不大</strong></em>。</p><p>我们可以提出来以下问题：</p><ol><li>为什么函数的频发调用会导致性能的下降？</li><li>怎么解决这种性能的下降？</li><li>什么是内联扩展？</li></ol><h1 id="为什么函数的频发调用会导致性能的下降？"><a href="#为什么函数的频发调用会导致性能的下降？" class="headerlink" title="为什么函数的频发调用会导致性能的下降？"></a>为什么函数的频发调用会导致性能的下降？</h1><p>函数调用通常涉及将参数压入堆栈、跳转到函数代码、执行函数代码、将返回值放入适当的位置、然后跳回到调用函数的地方。</p><h1 id="怎么解决这种性能的下降？"><a href="#怎么解决这种性能的下降？" class="headerlink" title="怎么解决这种性能的下降？"></a>怎么解决这种性能的下降？</h1><p>尾递归优化、死代码消除、常量传播和常量折叠、内联拓展等。这一章主要说内联拓展。</p><h1 id="什么是内联扩展"><a href="#什么是内联扩展" class="headerlink" title="什么是内联扩展"></a>什么是内联扩展</h1><p>维基百科：</p><pre><code>Inline expansion is used to eliminate the time overhead (excess time) when a function is called. It is typically used for functions that execute frequently. It also has a space benefit for very small functions, and is an enabling transformation for other optimizations.内联扩展用于消除调用函数时的时间开销(超额时间)。它通常用于频繁执行的函数。对于非常小的函数来说，它还具有空间优势，并且是一种支持其他优化的转换。</code></pre><p>频繁地调用函数可能会导致一些额外的开销，这种开销是由于函数调用时的堆栈操作、参数传递和返回值处理等因素引起的。</p><p>为了避免这种开销，编译器会尝试将函数调用处的代码替换为函数体，这个过程称为内联扩展（inline expansion）。</p><p>ref:<br><a href="https://www.jstage.jst.go.jp/article/sptj1978/44/3/44_3_206/_pdf">https://www.jstage.jst.go.jp/article/sptj1978/44/3/44_3_206/_pdf</a></p><p><a href="https://www.semanticscholar.org/search?q=Inline%20expansion&amp;sort=relevance">https://www.semanticscholar.org/search?q=Inline%20expansion&amp;sort=relevance</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;9021大家已经在卷运行时间了，这刚好就是$算法$发展的本质。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../assets/img/%E6%88%AA%E5%B1%8F2023-10-08%20%E4%B8%8B%E5%8D%8811.35.38.png&quot; alt=&quot;截屏2023</summary>
      
    
    
    
    
    <category term="计算机组成原理" scheme="https://longsizhuo123.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>122.买卖股票的最佳时期II</title>
    <link href="https://longsizhuo123.github.io/post/a75da5a.html"/>
    <id>https://longsizhuo123.github.io/post/a75da5a.html</id>
    <published>2023-10-02T13:23:00.000Z</published>
    <updated>2023-10-02T12:18:06.688Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h1><p><img src="../assets/img/%E6%88%AA%E5%B1%8F2023-10-02%20%E4%B8%8B%E5%8D%8811.16.25.png" alt="截屏2023-10-02 下午11.16.25.png"></p><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/">122.买卖股票的最佳时期II.md</a></p><h1 id="思想："><a href="#思想：" class="headerlink" title="思想："></a>思想：</h1><p>看到题忘记了还可以直接后一天的价格减前一天的价格，想的是构建最小子问题。<br>然后发现好像有点复杂，又做过（2023.1.13），才发现好像只要一行就行。</p><h1 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxProfit</span>(<span class="params">self, prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(<span class="built_in">max</span>(<span class="number">0</span>, prices[i] - prices[i - <span class="number">1</span>]) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(prices)))</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目：&quot;&gt;&lt;a href=&quot;#题目：&quot; class=&quot;headerlink&quot; title=&quot;题目：&quot;&gt;&lt;/a&gt;题目：&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;../assets/img/%E6%88%AA%E5%B1%8F2023-10-02%20%E4%B8%8B%E</summary>
      
    
    
    
    
    <category term="Python" scheme="https://longsizhuo123.github.io/tags/Python/"/>
    
    <category term="题解" scheme="https://longsizhuo123.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="动态规划" scheme="https://longsizhuo123.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="数组" scheme="https://longsizhuo123.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="贪心" scheme="https://longsizhuo123.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>121.买卖股票的最佳时期</title>
    <link href="https://longsizhuo123.github.io/post/3a21fe32.html"/>
    <id>https://longsizhuo123.github.io/post/3a21fe32.html</id>
    <published>2023-10-01T08:23:00.000Z</published>
    <updated>2023-10-01T07:28:49.082Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h1><p><img src="../assets/img/%E6%88%AA%E5%B1%8F2023-10-01%20%E4%B8%8B%E5%8D%886.24.27.png" alt="截屏2023-10-01 下午6.24.27.png"></p><p><a href="https://leetcode-cn.com/problems/number-of-flowers-that-can-be-planted-in-garden/">2251.花期内花的数目.md</a></p><h1 id="思想："><a href="#思想：" class="headerlink" title="思想："></a>思想：</h1><p>动态规划，找到最小子问题<br>最小子问题：第i天的最大利润 = max(第i-1天的最大利润, 第i天的价格 - 前i-1天的最小价格)</p><h1 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxProfit</span>(<span class="params">self, prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 最小子问题：第i天的最大利润 = max(第i-1天的最大利润, 第i天的价格 - 前i-1天的最小价格)</span></span><br><span class="line">        dp = [<span class="number">0</span>] * <span class="built_in">len</span>(prices)</span><br><span class="line">        min_price = prices[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(prices)):</span><br><span class="line">            dp[i] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>], prices[i] - min_price)</span><br><span class="line">            min_price = <span class="built_in">min</span>(min_price, prices[i])</span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目：&quot;&gt;&lt;a href=&quot;#题目：&quot; class=&quot;headerlink&quot; title=&quot;题目：&quot;&gt;&lt;/a&gt;题目：&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;../assets/img/%E6%88%AA%E5%B1%8F2023-10-01%20%E4%B8%8B%E</summary>
      
    
    
    
    
    <category term="Python" scheme="https://longsizhuo123.github.io/tags/Python/"/>
    
    <category term="题解" scheme="https://longsizhuo123.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="动态规划" scheme="https://longsizhuo123.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="数组" scheme="https://longsizhuo123.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>2251.花期内花的数目</title>
    <link href="https://longsizhuo123.github.io/post/3a21fe32.html"/>
    <id>https://longsizhuo123.github.io/post/3a21fe32.html</id>
    <published>2023-09-28T14:55:29.046Z</published>
    <updated>2023-09-28T15:00:18.289Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h1><p><img src="../assets/img/%E6%88%AA%E5%B1%8F2023-09-29%20%E4%B8%8A%E5%8D%8812.54.48.png" alt="截屏2023-09-29 上午12.54.48.png"></p><p><a href="https://leetcode-cn.com/problems/number-of-flowers-that-can-be-planted-in-garden/">2251.花期内花的数目.md</a></p><h1 id="思想："><a href="#思想：" class="headerlink" title="思想："></a>思想：</h1><p>看的题解，想法太复杂了。学了一个新的库，bisect，二分查找，可以用来查找插入位置。</p><p><code>bisect_right(a, x)</code>: 在有序列表a中查找x，返回x应该被插入的位置，这个位置位于a中所有相同元素的右侧。</p><p><code>bisect_left(a, x)</code>: 在有序列表a中查找x，返回x应该被插入的位置，这个位置位于a中所有相同元素的左侧。</p><p>我们可以使用bisect_right来找到所有在该人出现之前开花的花的数量，使用bisect_left来找到所有在该人出现之前凋零的花的数量。</p><h1 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fullBloomFlowers</span>(<span class="params">self, flowers: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], people: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        start, end = <span class="built_in">sorted</span>(a <span class="keyword">for</span> a, _ <span class="keyword">in</span> flowers), <span class="built_in">sorted</span>(b <span class="keyword">for</span> _, b <span class="keyword">in</span> flowers)</span><br><span class="line">        <span class="comment"># 计算该人之前有多少个开始-有多少个结束</span></span><br><span class="line">        <span class="keyword">return</span> [bisect_right(start, p) - bisect_left(end, p) <span class="keyword">for</span> p <span class="keyword">in</span> people]</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目：&quot;&gt;&lt;a href=&quot;#题目：&quot; class=&quot;headerlink&quot; title=&quot;题目：&quot;&gt;&lt;/a&gt;题目：&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;../assets/img/%E6%88%AA%E5%B1%8F2023-09-29%20%E4%B8%8A%E</summary>
      
    
    
    
    
    <category term="Python" scheme="https://longsizhuo123.github.io/tags/Python/"/>
    
    <category term="题解" scheme="https://longsizhuo123.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="前缀和" scheme="https://longsizhuo123.github.io/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    
    <category term="哈希表" scheme="https://longsizhuo123.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
    <category term="数组" scheme="https://longsizhuo123.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="排序" scheme="https://longsizhuo123.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
    <category term="二分查找" scheme="https://longsizhuo123.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
    <category term="有序集合" scheme="https://longsizhuo123.github.io/tags/%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>1333.餐厅过滤器</title>
    <link href="https://longsizhuo123.github.io/post/7f1331bc.html"/>
    <id>https://longsizhuo123.github.io/post/7f1331bc.html</id>
    <published>2023-09-27T05:44:00.000Z</published>
    <updated>2023-09-27T06:16:07.272Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h1><p><img src="../assets/img/%E6%88%AA%E5%B1%8F2023-09-27%20%E4%B8%8B%E5%8D%883.45.32.png" alt="截屏2023-09-27 下午3.45.32.png"></p><p><a href="https://leetcode-cn.com/problems/filter-restaurants-by-vegan-friendly-price-and-distance/">1333.餐厅过滤器.md</a></p><h1 id="思想："><a href="#思想：" class="headerlink" title="思想："></a>思想：</h1><p>这是一开始的pop思想，但是时间复杂度太高，400ms，后面改成了列表推导式。<br>想起了学长说过，pop()的运行时间还行，但是里面一旦加了索引，就会特别慢。<br>sorted 与 lambda 的用法：<br>lambda是Python中的匿名函数。在这里，lambda x: (x[1], x[0])定义了一个接受一个元素x（在这种情况下，x是restaurants列表中的一个子列表）并返回一个元组(x[1], x[0])的函数。</p><p>这意味着，排序首先基于每个子列表的第二个元素x[1]，然后在这个基础上基于第一个元素x[0]。换句话说，它首先按照x[1]进行排序，如果x[1]相同，则按照x[0]进行排序。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> ind &lt; <span class="built_in">len</span>(restaurants):</span><br><span class="line">     i = restaurants[ind]</span><br><span class="line">     <span class="keyword">if</span> veganFriendly == <span class="number">1</span> <span class="keyword">and</span> i[<span class="number">2</span>] == <span class="number">0</span>:</span><br><span class="line">         restaurants.pop(ind)</span><br><span class="line">     <span class="keyword">elif</span> maxPrice &lt; i[<span class="number">3</span>]:</span><br><span class="line">         restaurants.pop(ind)</span><br><span class="line">     <span class="keyword">elif</span> maxDistance &lt; i[<span class="number">4</span>]:</span><br><span class="line">         restaurants.pop(ind)</span><br><span class="line">     <span class="keyword">else</span>:</span><br><span class="line">         ind += <span class="number">1</span></span><br></pre></td></tr></table></figure><h1 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">filterRestaurants</span>(<span class="params">self, restaurants: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], veganFriendly: <span class="built_in">int</span>, maxPrice: <span class="built_in">int</span>, maxDistance: <span class="built_in">int</span></span>) -&gt; \</span><br><span class="line">            <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        restaurants = [</span><br><span class="line">            i <span class="keyword">for</span> i <span class="keyword">in</span> restaurants</span><br><span class="line">            <span class="keyword">if</span> (veganFriendly == <span class="number">0</span> <span class="keyword">or</span> i[<span class="number">2</span>] == veganFriendly)</span><br><span class="line">               <span class="keyword">and</span> i[<span class="number">3</span>] &lt;= maxPrice</span><br><span class="line">               <span class="keyword">and</span> i[<span class="number">4</span>] &lt;= maxDistance</span><br><span class="line">        ]</span><br><span class="line">        restaurants = <span class="built_in">sorted</span>(restaurants, key=<span class="keyword">lambda</span> x: (x[<span class="number">1</span>], x[<span class="number">0</span>]), reverse=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">return</span> [i[<span class="number">0</span>] <span class="keyword">for</span> i <span class="keyword">in</span> restaurants]</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目：&quot;&gt;&lt;a href=&quot;#题目：&quot; class=&quot;headerlink&quot; title=&quot;题目：&quot;&gt;&lt;/a&gt;题目：&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;../assets/img/%E6%88%AA%E5%B1%8F2023-09-27%20%E4%B8%8B%E</summary>
      
    
    
    
    
    <category term="Python" scheme="https://longsizhuo123.github.io/tags/Python/"/>
    
    <category term="题解" scheme="https://longsizhuo123.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="数组" scheme="https://longsizhuo123.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="排序" scheme="https://longsizhuo123.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>2582.递枕头</title>
    <link href="https://longsizhuo123.github.io/post/82e09f92.html"/>
    <id>https://longsizhuo123.github.io/post/82e09f92.html</id>
    <published>2023-09-26T14:00:00.000Z</published>
    <updated>2023-09-26T16:24:39.799Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h1><p><img src="../assets/img/%E6%88%AA%E5%B1%8F2023-09-27%20%E4%B8%8A%E5%8D%882.19.52.png" alt="截屏2023-09-27 上午2.19.52.png"></p><p><a href="https://leetcode-cn.com/problems/di-zhen-tou/">2582.递枕头.md</a></p><h1 id="思想："><a href="#思想：" class="headerlink" title="思想："></a>思想：</h1><p>数学题，找规律，n个人，间隔=n-1，在人群中的循环次数= $time // (n-1)$，循环次数为2的倍数则从头往后数，否则从后往前数。</p><p><img src="../assets/img/%E6%88%AA%E5%B1%8F2023-09-27%20%E4%B8%8A%E5%8D%882.24.10.png" alt="截屏2023-09-27 上午2.24.10.png"></p><h1 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">passThePillow</span>(<span class="params">self, n: <span class="built_in">int</span>, time: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> n &gt; time:</span><br><span class="line">            <span class="keyword">return</span> time + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> time // (n-<span class="number">1</span>) % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> time % (n-<span class="number">1</span>) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> n - time % (n-<span class="number">1</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目：&quot;&gt;&lt;a href=&quot;#题目：&quot; class=&quot;headerlink&quot; title=&quot;题目：&quot;&gt;&lt;/a&gt;题目：&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;../assets/img/%E6%88%AA%E5%B1%8F2023-09-27%20%E4%B8%8A%E</summary>
      
    
    
    
    
    <category term="Python" scheme="https://longsizhuo123.github.io/tags/Python/"/>
    
    <category term="题解" scheme="https://longsizhuo123.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="数学" scheme="https://longsizhuo123.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="模拟" scheme="https://longsizhuo123.github.io/tags/%E6%A8%A1%E6%8B%9F/"/>
    
  </entry>
  
  <entry>
    <title>146.LRU 缓存</title>
    <link href="https://longsizhuo123.github.io/post/b9130c0e.html"/>
    <id>https://longsizhuo123.github.io/post/b9130c0e.html</id>
    <published>2023-09-24T14:00:00.000Z</published>
    <updated>2023-09-24T15:27:31.156Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h1><p>第一次遇见：’2023/3/14-15:21’<br><img src="../assets/img/%E6%88%AA%E5%B1%8F2023-09-25%20%E4%B8%8A%E5%8D%881.14.08.png" alt="截屏2023-09-25 上午1.14.08.png"></p><p><a href="https://leetcode-cn.com/problems/lru-cache/">146.LRU 缓存.md</a></p><h1 id="思想："><a href="#思想：" class="headerlink" title="思想："></a>思想：</h1><p>简单的模拟，用字典就做出来了，好像完全没用到双向链表和LRU的思想。。。我有罪，依稀能记得半年前吹着空调做的。<br>题解就看代码的注释应该就能看懂，不懂的留言我会回复。</p><h1 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, capacity: <span class="built_in">int</span></span>):</span><br><span class="line">        self.capacity = capacity</span><br><span class="line">        self.cache = collections.OrderedDict()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self, key: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 如果key在字典中，返回value</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self.cache:</span><br><span class="line">            self.cache.move_to_end(key)</span><br><span class="line">            <span class="keyword">return</span> self.cache[key]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 如果key不在字典中，返回-1</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">put</span>(<span class="params">self, key: <span class="built_in">int</span>, value: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self.cache:</span><br><span class="line">            <span class="comment"># 如果key在字典中，更新value</span></span><br><span class="line">            self.cache.move_to_end(key)</span><br><span class="line">            self.cache[key] = value</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(self.cache) == self.capacity:</span><br><span class="line">                <span class="comment"># 如果key不在字典中，且字典已满，删除最近最少使用的元素</span></span><br><span class="line">                self.cache.popitem(last=<span class="literal">False</span>)</span><br><span class="line">            <span class="comment"># 如果key不在字典中，且字典未满，添加元素</span></span><br><span class="line">            <span class="comment"># self.cache.move_to_end(key)</span></span><br><span class="line">            self.cache[key] = value</span><br></pre></td></tr></table></figure><h1 id="第二种解法"><a href="#第二种解法" class="headerlink" title="第二种解法"></a>第二种解法</h1><p><img src="../assets/img/%E6%88%AA%E5%B1%8F2023-09-25%20%E4%B8%8A%E5%8D%881.25.22.png" alt="截屏2023-09-25 上午1.25.22.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>:</span><br><span class="line">    <span class="comment"># 提高访问属性的速度，并节省内存</span></span><br><span class="line">    __slots__ = <span class="string">&#x27;prev&#x27;</span>, <span class="string">&#x27;next&#x27;</span>, <span class="string">&#x27;key&#x27;</span>, <span class="string">&#x27;value&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, key=<span class="number">0</span>, value=<span class="number">0</span></span>):</span><br><span class="line">        self.key = key</span><br><span class="line">        self.value = value</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, capacity: <span class="built_in">int</span></span>):</span><br><span class="line">        self.capacity = capacity</span><br><span class="line">        self.dummy = Node()  <span class="comment"># 哨兵节点</span></span><br><span class="line">        self.dummy.prev = self.dummy</span><br><span class="line">        self.dummy.<span class="built_in">next</span> = self.dummy</span><br><span class="line">        self.key_to_node = <span class="built_in">dict</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_node</span>(<span class="params">self, key: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[Node]:</span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> self.key_to_node:  <span class="comment"># 没有这本书</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        node = self.key_to_node[key]  <span class="comment"># 有这本书</span></span><br><span class="line">        self.remove(node)  <span class="comment"># 把这本书抽出来</span></span><br><span class="line">        self.push_front(node)  <span class="comment"># 放在最上面</span></span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self, key: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        node = self.get_node(key)</span><br><span class="line">        <span class="keyword">return</span> node.value <span class="keyword">if</span> node <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">put</span>(<span class="params">self, key: <span class="built_in">int</span>, value: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        node = self.get_node(key)</span><br><span class="line">        <span class="keyword">if</span> node:  <span class="comment"># 有这本书</span></span><br><span class="line">            node.value = value  <span class="comment"># 更新 value</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.key_to_node[key] = node = Node(key, value)  <span class="comment"># 新书</span></span><br><span class="line">        self.push_front(node)  <span class="comment"># 放在最上面</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.key_to_node) &gt; self.capacity:  <span class="comment"># 书太多了</span></span><br><span class="line">            back_node = self.dummy.prev</span><br><span class="line">            <span class="keyword">del</span> self.key_to_node[back_node.key]</span><br><span class="line">            self.remove(back_node)  <span class="comment"># 去掉最后一本书</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 删除一个节点（抽出一本书）</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">remove</span>(<span class="params">self, x: Node</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        x.prev.<span class="built_in">next</span> = x.<span class="built_in">next</span></span><br><span class="line">        x.<span class="built_in">next</span>.prev = x.prev</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 在链表头添加一个节点（把一本书放在最上面）</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push_front</span>(<span class="params">self, x: Node</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        x.prev = self.dummy</span><br><span class="line">        x.<span class="built_in">next</span> = self.dummy.<span class="built_in">next</span></span><br><span class="line">        x.prev.<span class="built_in">next</span> = x</span><br><span class="line">        x.<span class="built_in">next</span>.prev = x</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目：&quot;&gt;&lt;a href=&quot;#题目：&quot; class=&quot;headerlink&quot; title=&quot;题目：&quot;&gt;&lt;/a&gt;题目：&lt;/h1&gt;&lt;p&gt;第一次遇见：’2023/3/14-15:21’&lt;br&gt;&lt;img src=&quot;../assets/img/%E6%88%AA%E5%B1</summary>
      
    
    
    
    
    <category term="Python" scheme="https://longsizhuo123.github.io/tags/Python/"/>
    
    <category term="题解" scheme="https://longsizhuo123.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="哈希表" scheme="https://longsizhuo123.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
    <category term="链表" scheme="https://longsizhuo123.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
    <category term="设计" scheme="https://longsizhuo123.github.io/tags/%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="双向链表" scheme="https://longsizhuo123.github.io/tags/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>6323. 将钱分给最多的儿童</title>
    <link href="https://longsizhuo123.github.io/post/b9130c0e.html"/>
    <id>https://longsizhuo123.github.io/post/b9130c0e.html</id>
    <published>2023-09-22T13:00:00.000Z</published>
    <updated>2023-09-24T15:13:14.946Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h1><p>第一次遇见：’2023/3/19-16:51’<br><img src="../assets/img/%E6%88%AA%E5%B1%8F2023-09-22%20%E4%B8%8B%E5%8D%8811.42.18.png" alt="截屏2023-09-22 下午11.42.18.png"><br><a href="https://leetcode.cn/problems/distribute-money-to-maximum-children/">6323. 将钱分给最多的儿童.md</a></p><h1 id="思想："><a href="#思想：" class="headerlink" title="思想："></a>思想：</h1><p>“————–”</p><p>这道题是上半年3月份的时候的周赛题目，题目链接：6323</p><p>“————–”</p><p>一开始就发现了这个是数学题，奈何写了半天不知道怎么处理最后剩下的钱。<br>于是写了一个列表，一个孩子一个孩子地给钱。<br>数学：<br>如果剩余 0 人，且 money&gt;0，那么必须分给一个已经分到 8 美元的人，<br>ans 减一。<br>如果剩余 1 人，且 money=3，为避免分配 4 美元，<br>那么必须分给一个已经分到 8 美元的人，ans 减一。<br>其它情况全部给一个人，如果这个人分配到 4 美元，<br>他再给另一个人 1 美元，这样 ans 不变。</p><p>以下为ylb大佬的解释：（2023-9-22更新）<br>如果 money&lt;children，那么一定存在儿童没有分到钱，返回 −1。</p><p>如果 money&gt;8×children，那么有 children−1 个儿童获得了 8 美元，剩下的一个儿童获得了 money−8×(children−1) 美元，返回 children−1。</p><p>如果 money=8×children−4，那么有 children−2 个儿童获得了 8 美元，剩下的两个儿童分摊剩下的 12 美元（只要不是 4, 8 美元就行），返回 children−2。</p><p>如果，我们假设有 x 个儿童获得了 8 美元，那么剩下的钱为 money−8×x，只要保证大于等于剩下的儿童数 children−x，就可以满足题意。因此，我们只需要求出 x 的最大值，即为答案。</p><h1 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h1><figure class="highlight python"><figcaption><span>列表</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">distMoney</span>(<span class="params">self, money: <span class="built_in">int</span>, children: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        money -= children</span><br><span class="line">        children_list = [<span class="number">1</span>] * children</span><br><span class="line">        <span class="keyword">if</span> money &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        counts = <span class="built_in">min</span>(money // <span class="number">7</span>, children)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(counts):</span><br><span class="line">            children_list[i] = <span class="number">8</span></span><br><span class="line">        children_list[-<span class="number">1</span>] += money - counts * <span class="number">7</span></span><br><span class="line">        counts = children_list.count(<span class="number">8</span>)</span><br><span class="line">        <span class="keyword">if</span> children_list[-<span class="number">1</span>] == <span class="number">4</span>:</span><br><span class="line">            <span class="keyword">if</span> children_list[-<span class="number">2</span>] != <span class="number">8</span>:</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                counts -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> counts</span><br></pre></td></tr></table></figure><figure class="highlight python"><figcaption><span>数学</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">distMoney</span>(<span class="params">self, money: <span class="built_in">int</span>, children: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        money -= children  <span class="comment"># 每人至少 1 美元</span></span><br><span class="line">        <span class="keyword">if</span> money &lt; <span class="number">0</span>: <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        ans = <span class="built_in">min</span>(money // <span class="number">7</span>, children)  <span class="comment"># 初步分配，让尽量多的人分到 8 美元</span></span><br><span class="line">        money -= ans * <span class="number">7</span></span><br><span class="line">        children -= ans</span><br><span class="line">        <span class="comment"># children == 0 and money：必须找一个前面分了 8 美元的人，分配完剩余的钱</span></span><br><span class="line">        <span class="comment"># children == 1 and money == 3：不能有人恰好分到 4 美元</span></span><br><span class="line">        <span class="keyword">if</span> children == <span class="number">0</span> <span class="keyword">and</span> money <span class="keyword">or</span> \</span><br><span class="line">           children == <span class="number">1</span> <span class="keyword">and</span> money == <span class="number">3</span>:</span><br><span class="line">            ans -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><figure class="highlight python"><figcaption><span>ylb</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">distMoney</span>(<span class="params">self, money: <span class="built_in">int</span>, children: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> money &lt; children:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> money &gt; <span class="number">8</span> * children:</span><br><span class="line">            <span class="keyword">return</span> children - <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> money == <span class="number">8</span> * children - <span class="number">4</span>:</span><br><span class="line">            <span class="keyword">return</span> children - <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> (money-children) // <span class="number">7</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目：&quot;&gt;&lt;a href=&quot;#题目：&quot; class=&quot;headerlink&quot; title=&quot;题目：&quot;&gt;&lt;/a&gt;题目：&lt;/h1&gt;&lt;p&gt;第一次遇见：’2023/3/19-16:51’&lt;br&gt;&lt;img src=&quot;../assets/img/%E6%88%AA%E5%B1</summary>
      
    
    
    
    
    <category term="Python" scheme="https://longsizhuo123.github.io/tags/Python/"/>
    
    <category term="题解" scheme="https://longsizhuo123.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>2591.将钱分给最多的儿童</title>
    <link href="https://longsizhuo123.github.io/post/6a9ab144.html"/>
    <id>https://longsizhuo123.github.io/post/6a9ab144.html</id>
    <published>2023-09-22T13:00:00.000Z</published>
    <updated>2023-09-22T13:58:05.487Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h1><p><img src="../assets/img/%E6%88%AA%E5%B1%8F2023-09-22%20%E4%B8%8B%E5%8D%8811.42.18.png" alt="截屏2023-09-22 下午11.42.18.png"><br><a href="https://leetcode-cn.com/problems/divide-money-to-k-people/">题目链接</a></p><h1 id="思想："><a href="#思想：" class="headerlink" title="思想："></a>思想：</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目：&quot;&gt;&lt;a href=&quot;#题目：&quot; class=&quot;headerlink&quot; title=&quot;题目：&quot;&gt;&lt;/a&gt;题目：&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;../assets/img/%E6%88%AA%E5%B1%8F2023-09-22%20%E4%B8%8B%E</summary>
      
    
    
    
    
    <category term="Python" scheme="https://longsizhuo123.github.io/tags/Python/"/>
    
    <category term="题解" scheme="https://longsizhuo123.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="数学" scheme="https://longsizhuo123.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="贪心" scheme="https://longsizhuo123.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>LCP 06.拿硬币</title>
    <link href="https://longsizhuo123.github.io/post/66079b7b.html"/>
    <id>https://longsizhuo123.github.io/post/66079b7b.html</id>
    <published>2023-09-20T14:00:00.000Z</published>
    <updated>2023-09-20T14:15:49.446Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h1><p><img src="../assets/img/%E6%88%AA%E5%B1%8F2023-09-21%20%E4%B8%8A%E5%8D%8812.12.09.png" alt="截屏2023-09-21 上午12.12.09.png"><br><a href="https://leetcode-cn.com/problems/na-ying-bi/">题目链接</a></p><h1 id="思想："><a href="#思想：" class="headerlink" title="思想："></a>思想：</h1><p>既然4需要两次，3也需要两次，那么说明这道题无非就是“尽量2个2个取，取不完的就计数+1”<br>虽然感觉还能在运行时间上再优化，但是我更喜欢写一行</p><h1 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minCount</span>(<span class="params">self, coins: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(i // <span class="number">2</span> + i % <span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> coins)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目：&quot;&gt;&lt;a href=&quot;#题目：&quot; class=&quot;headerlink&quot; title=&quot;题目：&quot;&gt;&lt;/a&gt;题目：&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;../assets/img/%E6%88%AA%E5%B1%8F2023-09-21%20%E4%B8%8A%E</summary>
      
    
    
    
    
    <category term="Python" scheme="https://longsizhuo123.github.io/tags/Python/"/>
    
    <category term="题解" scheme="https://longsizhuo123.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="数学" scheme="https://longsizhuo123.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="数组" scheme="https://longsizhuo123.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>213.打家劫舍 III</title>
    <link href="https://longsizhuo123.github.io/post/86590614.html"/>
    <id>https://longsizhuo123.github.io/post/86590614.html</id>
    <published>2023-09-18T03:00:00.000Z</published>
    <updated>2023-09-18T03:15:57.245Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h1><p><img src="../assets/img/%E6%88%AA%E5%B1%8F2023-09-18%20%E4%B8%8B%E5%8D%881.08.41.png" alt="截屏2023-09-18 下午1.08.41.png"><br><a href="https://leetcode-cn.com/problems/house-robber-iii/">题目链接</a></p><h1 id="思想："><a href="#思想：" class="headerlink" title="思想："></a>思想：</h1><p>参考了 ylb 大佬的题解，<br>这道题和打家劫舍1和2的区别在于，这道题是一棵二叉树，而且不能打劫相邻的节点。<br>所以他的最小子问题是：打劫了当前节点，就不能打劫自己的左右孩子。<br>如果偷取 root 节点，那么不能偷取其左右子节点，结果为 <code>root.val+lb +rb</code>；<br>如果不偷取 root 节点，那么可以偷取其左右子节点，结果为 <code>max(la, lb)+max(ra ,rb)</code>。</p><h1 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rob</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">_rob</span>(<span class="params">root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; (<span class="built_in">int</span>, <span class="built_in">int</span>):</span><br><span class="line">            <span class="comment"># 最小子问题:dp[i]=dp[i-2]+nums[i], dp[i-1]</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">            la, lb = _rob(root.left)</span><br><span class="line">            ra, rb = _rob(root.right)</span><br><span class="line">            <span class="keyword">return</span> root.val + lb + rb, <span class="built_in">max</span>(la, lb) + <span class="built_in">max</span>(ra, rb)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(_rob(root))</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目：&quot;&gt;&lt;a href=&quot;#题目：&quot; class=&quot;headerlink&quot; title=&quot;题目：&quot;&gt;&lt;/a&gt;题目：&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;../assets/img/%E6%88%AA%E5%B1%8F2023-09-18%20%E4%B8%8B%E</summary>
      
    
    
    
    
    <category term="Python" scheme="https://longsizhuo123.github.io/tags/Python/"/>
    
    <category term="题解" scheme="https://longsizhuo123.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="动态规划" scheme="https://longsizhuo123.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="二叉树" scheme="https://longsizhuo123.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    <category term="深度优先搜索" scheme="https://longsizhuo123.github.io/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
    <category term="树" scheme="https://longsizhuo123.github.io/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>213.打家劫舍 II</title>
    <link href="https://longsizhuo123.github.io/post/85beb0bf.html"/>
    <id>https://longsizhuo123.github.io/post/85beb0bf.html</id>
    <published>2023-09-17T14:00:00.000Z</published>
    <updated>2023-09-17T16:35:40.131Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h1><p><img src="../assets/img/%E6%88%AA%E5%B1%8F2023-09-18%20%E4%B8%8A%E5%8D%882.31.30.png" alt="截屏2023-09-18 上午2.31.30.png"><br><a href="https://leetcode-cn.com/problems/house-robber-ii/">题目链接</a></p><h1 id="思想："><a href="#思想：" class="headerlink" title="思想："></a>思想：</h1><p>这一次终于懂一点动态规划了，首先是最小子问题，我一开始认为是考虑从哪里开始，是从第一个还是第二个开始（这刚好是和打家劫舍1的区别）。<br>但实际上最小子问题还是和打家劫舍1一样：是否打劫当前房子。<br>首先我们设置一个<code>dp</code>数组，<code>dp[i]</code>表示打劫到第<code>i</code>个房子时的最大收益。<br>那么我们打劫当前房子后 <code>dp[i] = dp[i-2] + nums[i]</code>，(因为打劫了当前房子就不能打劫之前的房子)，不打劫当前房子 <code>dp[i] = dp[i-1]</code>。<br>所以我们可以得到状态转移方程：<code>dp[i] = max(dp[i-2] + nums[i], dp[i-1])</code>。<br>最后分类讨论打劫第一个还是第二个开始就行。</p><h1 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rob</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">rob1</span>(<span class="params">nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">            ans = <span class="number">0</span></span><br><span class="line">            dp = [<span class="number">0</span>] * <span class="built_in">len</span>(nums)</span><br><span class="line">            <span class="comment"># def: dp[i]表示打劫第i家的最大收益</span></span><br><span class="line">            <span class="comment"># 偷窃 第i家房屋，则收益为dp[i-2]+nums[i], 不偷窃第i家房屋，则收益为dp[i-1]</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">                dp[i] = <span class="built_in">max</span>(dp[i - <span class="number">2</span>] + nums[i], dp[i - <span class="number">1</span>])</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, dp[i])</span><br><span class="line">            <span class="keyword">return</span> ans</span><br><span class="line">        <span class="comment"># 打劫第一家，或者第二家开始</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(rob1(nums[:-<span class="number">1</span>]), rob1(nums[<span class="number">1</span>:])) <span class="keyword">if</span> <span class="built_in">len</span>(nums) != <span class="number">1</span> <span class="keyword">else</span> nums[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目：&quot;&gt;&lt;a href=&quot;#题目：&quot; class=&quot;headerlink&quot; title=&quot;题目：&quot;&gt;&lt;/a&gt;题目：&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;../assets/img/%E6%88%AA%E5%B1%8F2023-09-18%20%E4%B8%8A%E</summary>
      
    
    
    
    
    <category term="Python" scheme="https://longsizhuo123.github.io/tags/Python/"/>
    
    <category term="题解" scheme="https://longsizhuo123.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="动态规划" scheme="https://longsizhuo123.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="数组" scheme="https://longsizhuo123.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>LCP 50.宝石补给</title>
    <link href="https://longsizhuo123.github.io/post/762ca698.html"/>
    <id>https://longsizhuo123.github.io/post/762ca698.html</id>
    <published>2023-09-15T04:12:00.000Z</published>
    <updated>2023-09-15T06:31:10.104Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h1><p><img src="../assets/img/%E6%88%AA%E5%B1%8F2023-09-15%20%E4%B8%8B%E5%8D%882.23.12.png" alt="截屏2023-09-15 下午2.23.12.png"><br><a href="https://leetcode.cn/problems/bao-zi-fen-shu/">题目链接</a></p><h1 id="思想："><a href="#思想：" class="headerlink" title="思想："></a>思想：</h1><p>LCP开头居然是新手村的意思，简单的模拟，遍历operations，对gem进行加减计算。</p><h1 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">giveGem</span>(<span class="params">self, gem: <span class="type">List</span>[<span class="built_in">int</span>], operations: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">for</span> i, j <span class="keyword">in</span> operations:</span><br><span class="line">            trade = gem[i] // <span class="number">2</span></span><br><span class="line">            gem[i] -= trade</span><br><span class="line">            gem[j] += trade</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(gem)-<span class="built_in">min</span>(gem)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目：&quot;&gt;&lt;a href=&quot;#题目：&quot; class=&quot;headerlink&quot; title=&quot;题目：&quot;&gt;&lt;/a&gt;题目：&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;../assets/img/%E6%88%AA%E5%B1%8F2023-09-15%20%E4%B8%8B%E</summary>
      
    
    
    
    
    <category term="Python" scheme="https://longsizhuo123.github.io/tags/Python/"/>
    
    <category term="题解" scheme="https://longsizhuo123.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="数组" scheme="https://longsizhuo123.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="模拟" scheme="https://longsizhuo123.github.io/tags/%E6%A8%A1%E6%8B%9F/"/>
    
  </entry>
  
  <entry>
    <title>1222.可以攻击国王的皇后</title>
    <link href="https://longsizhuo123.github.io/post/a6577367.html"/>
    <id>https://longsizhuo123.github.io/post/a6577367.html</id>
    <published>2023-09-14T13:12:00.000Z</published>
    <updated>2023-09-14T14:26:44.647Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h1><p><img src="../assets/img/%E6%88%AA%E5%B1%8F2023-09-15%20%E4%B8%8A%E5%8D%8812.10.07.png" alt="截屏2023-09-15 上午12.10.07.png"><br><a href="https://leetcode-cn.com/problems/queens-that-can-attack-the-king/">题目链接</a></p><h1 id="思想："><a href="#思想：" class="headerlink" title="思想："></a>思想：</h1><p>直接模拟，分别判断横向，纵向，对角线上的皇后是否存在，如果存在，就记录下来，最后返回。</p><p>答案的方法和我的类似，但是更加简洁，从国王往外走，记录碰到的第一个皇后。</p><h1 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h1><figure class="highlight python"><figcaption><span>我流</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">queensAttacktheKing</span>(<span class="params">self, queens: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], king: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        x = king[<span class="number">0</span>]</span><br><span class="line">        y = king[<span class="number">1</span>]</span><br><span class="line">        x_left_diff = <span class="number">64</span></span><br><span class="line">        x_right_diff = <span class="number">64</span></span><br><span class="line">        left_high_diff = <span class="number">64</span></span><br><span class="line">        left_low_diff = <span class="number">64</span></span><br><span class="line">        right_high_diff = <span class="number">64</span></span><br><span class="line">        right_low_diff = <span class="number">64</span></span><br><span class="line">        y_left_diff = <span class="number">64</span></span><br><span class="line">        y_right_diff = <span class="number">64</span></span><br><span class="line">        res = [[]] * <span class="number">8</span></span><br><span class="line">        <span class="built_in">print</span>(res)</span><br><span class="line">        <span class="keyword">for</span> i, j <span class="keyword">in</span> queens:</span><br><span class="line">            <span class="comment"># 横向</span></span><br><span class="line">            <span class="keyword">if</span> i == x:</span><br><span class="line">                <span class="keyword">if</span> j &lt; y <span class="keyword">and</span> <span class="built_in">abs</span>(j - y) &lt; x_left_diff:</span><br><span class="line">                    res[<span class="number">0</span>] = [i, j]</span><br><span class="line">                    x_left_diff = <span class="built_in">abs</span>(j - y)</span><br><span class="line">                <span class="keyword">elif</span> j &gt; y <span class="keyword">and</span> <span class="built_in">abs</span>(j - y) &lt; x_right_diff:</span><br><span class="line">                    res[<span class="number">1</span>] = [i, j]</span><br><span class="line">                    x_right_diff = <span class="built_in">abs</span>(j - y)</span><br><span class="line">            <span class="comment"># 纵向</span></span><br><span class="line">            <span class="keyword">elif</span> j == y:</span><br><span class="line">                <span class="keyword">if</span> i &lt; x <span class="keyword">and</span> <span class="built_in">abs</span>(i - x) &lt; y_left_diff:</span><br><span class="line">                    res[<span class="number">6</span>] = [i, j]</span><br><span class="line">                    y_left_diff = <span class="built_in">abs</span>(i - x)</span><br><span class="line">                <span class="keyword">elif</span> i &gt; x <span class="keyword">and</span> <span class="built_in">abs</span>(i - x) &lt; y_right_diff:</span><br><span class="line">                    res[<span class="number">7</span>] = [i, j]</span><br><span class="line">                    y_right_diff = <span class="built_in">abs</span>(i - x)</span><br><span class="line">            <span class="comment"># 对角线上</span></span><br><span class="line">            <span class="keyword">elif</span> <span class="built_in">abs</span>(i - x) == <span class="built_in">abs</span>(j - y):</span><br><span class="line">                <span class="keyword">if</span> i &lt; x <span class="keyword">and</span> j &lt; y <span class="keyword">and</span> <span class="built_in">abs</span>(i - x) &lt; left_high_diff:</span><br><span class="line">                    res[<span class="number">2</span>] = [i, j]</span><br><span class="line">                    left_high_diff = <span class="built_in">abs</span>(i - x)</span><br><span class="line">                <span class="keyword">elif</span> i &lt; x <span class="keyword">and</span> j &gt; y <span class="keyword">and</span> <span class="built_in">abs</span>(i - x) &lt; left_low_diff:</span><br><span class="line">                    res[<span class="number">3</span>] = [i, j]</span><br><span class="line">                    left_low_diff = <span class="built_in">abs</span>(i - x)</span><br><span class="line">                <span class="keyword">elif</span> i &gt; x <span class="keyword">and</span> j &lt; y <span class="keyword">and</span> <span class="built_in">abs</span>(i - x) &lt; right_high_diff:</span><br><span class="line">                    res[<span class="number">4</span>] = [i, j]</span><br><span class="line">                    right_high_diff = <span class="built_in">abs</span>(i - x)</span><br><span class="line">                <span class="keyword">elif</span> i &gt; x <span class="keyword">and</span> j &gt; y <span class="keyword">and</span> <span class="built_in">abs</span>(i - x) &lt; right_low_diff:</span><br><span class="line">                    res[<span class="number">5</span>] = [i, j]</span><br><span class="line">                    right_low_diff = <span class="built_in">abs</span>(i - x)</span><br><span class="line">        <span class="keyword">return</span> [i <span class="keyword">for</span> i <span class="keyword">in</span> res <span class="keyword">if</span> i != []]</span><br></pre></td></tr></table></figure><figure class="highlight python"><figcaption><span>答案</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">queensAttacktheKing</span>(<span class="params">self, queens: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], king: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        s = <span class="built_in">set</span>(<span class="built_in">map</span>(<span class="built_in">tuple</span>, queens))</span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">for</span> dx, dy <span class="keyword">in</span> (<span class="number">1</span>, <span class="number">0</span>), (<span class="number">1</span>, <span class="number">1</span>), (<span class="number">0</span>, <span class="number">1</span>), (-<span class="number">1</span>, <span class="number">1</span>), (-<span class="number">1</span>, <span class="number">0</span>), (-<span class="number">1</span>, -<span class="number">1</span>), (<span class="number">0</span>, -<span class="number">1</span>), (<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            x, y = king[<span class="number">0</span>] + dx, king[<span class="number">1</span>] + dy</span><br><span class="line">            <span class="keyword">while</span> <span class="number">0</span> &lt;= x &lt; <span class="number">8</span> <span class="keyword">and</span> <span class="number">0</span> &lt;= y &lt; <span class="number">8</span>:</span><br><span class="line">                <span class="keyword">if</span> (x, y) <span class="keyword">in</span> s:</span><br><span class="line">                    ans.append([x, y])</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                x += dx</span><br><span class="line">                y += dy</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目：&quot;&gt;&lt;a href=&quot;#题目：&quot; class=&quot;headerlink&quot; title=&quot;题目：&quot;&gt;&lt;/a&gt;题目：&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;../assets/img/%E6%88%AA%E5%B1%8F2023-09-15%20%E4%B8%8A%E</summary>
      
    
    
    
    
    <category term="Python" scheme="https://longsizhuo123.github.io/tags/Python/"/>
    
    <category term="题解" scheme="https://longsizhuo123.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="数组" scheme="https://longsizhuo123.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="矩阵" scheme="https://longsizhuo123.github.io/tags/%E7%9F%A9%E9%98%B5/"/>
    
    <category term="模拟" scheme="https://longsizhuo123.github.io/tags/%E6%A8%A1%E6%8B%9F/"/>
    
  </entry>
  
  <entry>
    <title>2596.检查骑士巡逻方案</title>
    <link href="https://longsizhuo123.github.io/post/29546b92.html"/>
    <id>https://longsizhuo123.github.io/post/29546b92.html</id>
    <published>2023-09-13T07:12:00.000Z</published>
    <updated>2023-09-13T07:56:56.102Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h1><p><img src="../assets/img/%E6%88%AA%E5%B1%8F2023-09-13%20%E4%B8%8B%E5%8D%885.14.07.png" alt="截屏2023-09-13 下午5.14.07.png"><br><a href="https://leetcode.cn/problems/check-knight-tour-configuration/description/?envType=daily-question&envId=2023-09-13">题目链接</a></p><h1 id="思想："><a href="#思想：" class="headerlink" title="思想："></a>思想：</h1><p>第一眼以为是 N皇后 问题，然后读了半天没读懂题，所以去看了一眼答案（）。<br>原来<code>grid[row][col] 表示单元格 (row, col) 是骑士访问的第 grid[row][col] 个单元格。</code>的意思是<code>pos[grid[i][j]] = (i, j)</code><br>然后这下就懂了，设置个初始值（2，1），然后从（0，0）开始遍历每个点与<code>last</code>的值的差值是否是2，1或者1，2，如果不是，就返回False。</p><pre><code>在答案中，ylb用的是pairwise的方法计算前后两个元素for (x1, y1), (x2, y2) in pairwise(pos): dx, dy = abs(x1 - x2), abs(y1 - y2)</code></pre><h1 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">checkValidGrid</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> grid[<span class="number">0</span>][<span class="number">0</span>]:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        n = <span class="built_in">len</span>(grid)</span><br><span class="line">        pos = [(<span class="number">0</span>, <span class="number">0</span>)] * (n * n)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                pos[grid[i][j]] = (i, j)</span><br><span class="line">        last = -<span class="number">2</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i, j <span class="keyword">in</span> pos:</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">abs</span>(i - last[<span class="number">0</span>]) == <span class="number">2</span> <span class="keyword">and</span> <span class="built_in">abs</span>(j - last[<span class="number">1</span>]) == <span class="number">1</span>) <span class="keyword">or</span> \</span><br><span class="line">                    (<span class="built_in">abs</span>(i - last[<span class="number">0</span>]) == <span class="number">1</span> <span class="keyword">and</span> <span class="built_in">abs</span>(j - last[<span class="number">1</span>]) == <span class="number">2</span>):</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(i, j)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            last = (i, j)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目：&quot;&gt;&lt;a href=&quot;#题目：&quot; class=&quot;headerlink&quot; title=&quot;题目：&quot;&gt;&lt;/a&gt;题目：&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;../assets/img/%E6%88%AA%E5%B1%8F2023-09-13%20%E4%B8%8B%E</summary>
      
    
    
    
    
    <category term="Python" scheme="https://longsizhuo123.github.io/tags/Python/"/>
    
    <category term="题解" scheme="https://longsizhuo123.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="数组" scheme="https://longsizhuo123.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="矩阵" scheme="https://longsizhuo123.github.io/tags/%E7%9F%A9%E9%98%B5/"/>
    
    <category term="模拟" scheme="https://longsizhuo123.github.io/tags/%E6%A8%A1%E6%8B%9F/"/>
    
    <category term="深度优先搜索" scheme="https://longsizhuo123.github.io/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
    <category term="广度优先搜索" scheme="https://longsizhuo123.github.io/tags/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>1462.课程表IV</title>
    <link href="https://longsizhuo123.github.io/post/5f312ae.html"/>
    <id>https://longsizhuo123.github.io/post/5f312ae.html</id>
    <published>2023-09-12T09:57:00.000Z</published>
    <updated>2023-09-12T13:03:25.296Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h1><p><img src="../assets/img/img_2.png" alt="img_2.png"></p><p><a href="https://leetcode.cn/problems/course-schedule-iv/?envType=daily-question&envId=2023-09-12">[1460]课程表IV.md</a></p><h1 id="思想："><a href="#思想：" class="headerlink" title="思想："></a>思想：</h1><p>一开始的想法是构建有向图，然后在有向图中找到query的两个点是否有父子关系。<br>但看了ylb的答案后，发现先计算出可达性更快。<br>首先遍历prerequirements，将所有的可达性记录下来。<br>然后三重循环，连接所有的可达性。</p><pre><code>i-&gt;j-&gt;k，如果i-&gt;k，那么i-&gt;k就是可达的。</code></pre><h1 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">checkIfPrerequisite</span>(<span class="params">self, n: <span class="built_in">int</span>, prerequisites: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], queries: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[</span><br><span class="line">        <span class="built_in">bool</span>]:</span><br><span class="line">        f = [[<span class="literal">False</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        <span class="keyword">for</span> a, b <span class="keyword">in</span> prerequisites:</span><br><span class="line">            f[a][b] = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                    f[i][j] = f[i][j] <span class="keyword">or</span> (f[i][k] <span class="keyword">and</span> f[k][j])</span><br><span class="line">        <span class="keyword">return</span> [f[a][b] <span class="keyword">for</span> a, b <span class="keyword">in</span> queries]</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目：&quot;&gt;&lt;a href=&quot;#题目：&quot; class=&quot;headerlink&quot; title=&quot;题目：&quot;&gt;&lt;/a&gt;题目：&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;../assets/img/img_2.png&quot; alt=&quot;img_2.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href</summary>
      
    
    
    
    
    <category term="Python" scheme="https://longsizhuo123.github.io/tags/Python/"/>
    
    <category term="题解" scheme="https://longsizhuo123.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="深度优先搜索" scheme="https://longsizhuo123.github.io/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
    <category term="广度优先搜索" scheme="https://longsizhuo123.github.io/tags/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
    <category term="图" scheme="https://longsizhuo123.github.io/tags/%E5%9B%BE/"/>
    
    <category term="拓扑排序" scheme="https://longsizhuo123.github.io/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>630.课程表III</title>
    <link href="https://longsizhuo123.github.io/post/e14241e.html"/>
    <id>https://longsizhuo123.github.io/post/e14241e.html</id>
    <published>2023-09-11T16:25:00.000Z</published>
    <updated>2023-09-11T15:45:19.495Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h1><p><img src="../assets/img/img_1.png" alt="img_1.png"></p><p><a href="https://leetcode.cn/problems/course-schedule-iii/">题目链接</a></p><h1 id="思想："><a href="#思想：" class="headerlink" title="思想："></a>思想：</h1><p>思路来自于宫水三叶的贪心 + 优先队列，</p><ol><li>首先，我们按课程的结束时间对它们进行排序。这样做的目的是尝试每个课程，看看它能否适应我们的时间表。</li><li>因为Python的heapq默认是一个最小堆，所以当我们加入一个课程时，我们使用其持续时间的负数，从而使得堆顶部始终是持续时间最长的课程。</li><li>当遍历每个课程时，尝试把它加入到我们的日程中。但是，如果我们发现加入该课程后总时间超过了该课程的结束时间，那么我们需要从我们的日程中去掉一个课程，最好去掉那个持续时间最长的课程，因为这将释放出最多的时间，这也是为什么使用一个最大堆。<br><code>sum += heapq.heappop(q)</code></li><li>Java中的<code>Arrays.sort(courses, (a,b)-&gt;a[1]-b[1]); </code>等同于Python中的<code>courses.sort(key=lambda x: x[1])</code></li></ol><p>以下引用宫水三叶解法原文，关于为什么使用greedy：</p><pre><code>题目是要我们构造出一种可行的排列，排列中每个课程的实际结束时间满足「最晚完成时间」要求，求可行排序的最大长度（每个课程对答案的贡献都是 1）。这容易引导我们往「泛化背包」方面进行思考：简单来说，对于某个物品（课程）而言，在不同条件下成本不同，在时间轴 `[1,courses[i][1]−courses[i][0]]` 上该物品可被选，成本为其持续时间，在比该范围大的数轴上无法被选，成本为正无穷。因此某一段特定的时间轴上，问题可抽象成有条件限制的组合优化问题。由于数据范围为 10^4，泛化背包做法需要记录的维度大于一维，不予考虑。再然后容易想到「二分」，显然在以最大选择数量 ans 为分割点的数组上具有「二段性」：1. 使用数量小于等于 ans 的课程能够构造出合法排序（考虑在最长合法序列上做减法即可）；2. 使用数量大于 ans 的课程无法构造出合法排列。此时二分范围为 `[0,n]`，问题转化为：如何在 `O(n)` 检查是否可构造出某个长度 len 的合法排列（实现 `check` 方法）。常规的线性扫描做法无法确定是否存在某个长度的合法排列，因此二分不予考虑。我们需要运用「贪心」思维考虑可能的方案。</code></pre><h1 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">scheduleCourse</span>(<span class="params">self, courses: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        courses.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># This will be a max-heap based on course duration</span></span><br><span class="line">        q = []</span><br><span class="line">        <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> courses:</span><br><span class="line">            d, e = c</span><br><span class="line">            <span class="built_in">sum</span> += d</span><br><span class="line">            heapq.heappush(q, -d)</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">sum</span> &gt; e:</span><br><span class="line">                <span class="built_in">sum</span> += heapq.heappop(q)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(q)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目：&quot;&gt;&lt;a href=&quot;#题目：&quot; class=&quot;headerlink&quot; title=&quot;题目：&quot;&gt;&lt;/a&gt;题目：&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;../assets/img/img_1.png&quot; alt=&quot;img_1.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href</summary>
      
    
    
    
    
    <category term="Python" scheme="https://longsizhuo123.github.io/tags/Python/"/>
    
    <category term="题解" scheme="https://longsizhuo123.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="贪心" scheme="https://longsizhuo123.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
    <category term="优先队列" scheme="https://longsizhuo123.github.io/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>GO语言# GO语言可爱捏</title>
    <link href="https://longsizhuo123.github.io/post/67fc8613.html"/>
    <id>https://longsizhuo123.github.io/post/67fc8613.html</id>
    <published>2023-07-27T08:03:55.611Z</published>
    <updated>2023-07-27T08:03:55.611Z</updated>
    
    <content type="html"><![CDATA[<p><img src="../assets/img/motorcycle.svg" alt="motorcycle.svg"></p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Hello world&quot;</span>)</span><br><span class="line">arr := []<span class="type">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line">fmt.Println(a(arr))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">a</span><span class="params">(x []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(x); i++ &#123;</span><br><span class="line"><span class="keyword">if</span> i%<span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">x[i] = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight golang"><figcaption><span>修改字符串</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="string">&quot;hello&quot;</span></span><br><span class="line">c := []<span class="type">byte</span>(s)  <span class="comment">// 将字符串 s 转换为 []byte 类型</span></span><br><span class="line">c[<span class="number">0</span>] = <span class="string">&#x27;c&#x27;</span></span><br><span class="line">s2 := <span class="type">string</span>(c)  <span class="comment">// 再转换回 string 类型</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, s2)</span><br><span class="line"></span><br><span class="line">s := <span class="string">&quot;hello&quot;</span></span><br><span class="line">s = <span class="string">&quot;c&quot;</span> + s[<span class="number">1</span>:] <span class="comment">// 字符串虽不能更改，但可进行切片操作</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, s)</span><br></pre></td></tr></table></figure><p>如果要声明一个多行的字符串怎么办？可以通过`来声明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">m := `hello</span><br><span class="line">world`</span><br></pre></td></tr></table></figure><p>` 括起的字符串为Raw字符串，即字符串在代码中的形式就是打印时的形式，它没有字符转义，换行也将原样输出</p><h1 id="错误类型"><a href="#错误类型" class="headerlink" title="错误类型"></a>错误类型</h1><p>Go内置有一个error类型，专门用来处理错误信息，Go的package里面还专门有一个包errors来处理错误：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">err := errors.New(<span class="string">&quot;emit macho dwarf: elf header corrupted&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Print(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;../assets/img/motorcycle.svg&quot; alt=&quot;motorcycle.svg&quot;&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight golang&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;sp</summary>
      
    
    
    
    
    <category term="Python" scheme="https://longsizhuo123.github.io/tags/Python/"/>
    
    <category term="题解" scheme="https://longsizhuo123.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>置顶文章</title>
    <link href="https://longsizhuo123.github.io/post/edc2b94.html"/>
    <id>https://longsizhuo123.github.io/post/edc2b94.html</id>
    <published>2023-07-27T08:03:55.611Z</published>
    <updated>2023-07-27T08:03:55.611Z</updated>
    
    <content type="html"><![CDATA[<h1 id="longsizhuo123-github-io"><a href="#longsizhuo123-github-io" class="headerlink" title="longsizhuo123.github.io"></a>longsizhuo123.github.io</h1><p><img src="https://user-images.githubusercontent.com/114939201/214082770-35d1fb45-9891-4b73-ba89-18e33030640f.png" alt="pattern_stripes-1_1_2_0-0_125_1__cc2a35_4f372d_00a1b0_edc951_eb6941"></p><p><em>“Maybe it could be a nice memory”</em></p><p>Welcome to my personal blog repository on Github! My name is Sizhuo Long, and I am currently a student in Australia. This repository is home to my personal blog, which is built using the HEXO static site generator. </p><p>On my blog, you’ll find a variety of content including my thoughts on technology, programming, and the latest developments in my field of study. I also share my experiences and lessons learned from the projects I’ve worked on. </p><p>I hope that by sharing my knowledge and insights, I can help others who are interested in the same topics. I welcome any comments and feedback, and I am always open to collaboration. </p><p><strong>Thank you for visiting my blog</strong>, I hope you will find something interesting here. And I would really appreciate it if you could pay more attention to my blog and <strong>follow me</strong>.</p><h3 id="Why-you-should-follow-me"><a href="#Why-you-should-follow-me" class="headerlink" title="Why you should follow me"></a>Why you should follow me</h3><ul><li>I’ll share my personal experiences and thoughts on technology and programming </li><li>I’ll keep you updated on the latest developments in my field of study</li><li>I’m open to collaboration and feedback.</li></ul><h3 id="How-to-contact-me"><a href="#How-to-contact-me" class="headerlink" title="How to contact me"></a>How to contact me</h3><ul><li>Email: <a href="mailto:&#x6c;&#111;&#110;&#103;&#115;&#x69;&#122;&#x68;&#x75;&#111;&#64;&#103;&#x6d;&#97;&#x69;&#108;&#x2e;&#x63;&#x6f;&#x6d;">&#x6c;&#111;&#110;&#103;&#115;&#x69;&#122;&#x68;&#x75;&#111;&#64;&#103;&#x6d;&#97;&#x69;&#108;&#x2e;&#x63;&#x6f;&#x6d;</a></li><li>LinkedIn: <a href="https://www.linkedin.com/in/longsizhuo/">Sizhuo Long</a></li><li>XiaoHongShu(Small RedBook): <a href="https://www.xiaohongshu.com/user/profile/5c0b8cc2000000000601e809">@sizhuo_long</a></li></ul><p>Thank you for reading, and I hope you enjoy my blog!</p><p><img src="https://user-images.githubusercontent.com/114939201/214082782-ae84027e-0a15-4ed4-843b-00a29ea19480.png" alt="pattern_stripes-1_1_2_0-0_125_1__cc2a35_4f372d_00a1b0_edc951_eb6941"></p><p><strong><a href="https://longsizhuo.shinyapps.io/long/">面向单细胞RNA数据分析工具</a></strong><br>以前做的项目，还有很多错误，勿喷。<br><strong><a href="html/Sichuan_Traveler/index.html">蜀地旅行菌</a></strong><br>这是一个本科大二的时候的一个小作业，是小组作业。一开始因为链接不了<code>html</code>文件，阅读了很多很多官方文档或者CSDN文档<br>    。最后阅读了一篇文章，说是HEXO在当你<code>generate</code>的时候，就会把source中的文件append到public中去，后来试了很多次，发现直接以<br>public为源文件夹，调用目录即可。虽然这样就会导致无法在md文档中超链接到文件。    </p><p>同时，也存在新的bug未解决：login.html无法和index.html相互跳转<br>Linkin:</p><div class="badge-base LI-profile-badge" data-locale="zh_CN" data-size="medium" data-theme="dark" data-type="HORIZONTAL" data-vanity="longsizhuo" data-version="v1"><a class="badge-base__link LI-simple-link" href="https://au.linkedin.com/in/longsizhuo?trk=profile-badge">Sizhuo Long</a></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;longsizhuo123-github-io&quot;&gt;&lt;a href=&quot;#longsizhuo123-github-io&quot; class=&quot;headerlink&quot; title=&quot;longsizhuo123.github.io&quot;&gt;&lt;/a&gt;longsizhuo123.git</summary>
      
    
    
    
    <category term="前端" scheme="https://longsizhuo123.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="HEXO" scheme="https://longsizhuo123.github.io/categories/%E5%89%8D%E7%AB%AF/HEXO/"/>
    
    <category term="未解决" scheme="https://longsizhuo123.github.io/categories/%E6%9C%AA%E8%A7%A3%E5%86%B3/"/>
    
    <category term="存在bug" scheme="https://longsizhuo123.github.io/categories/%E6%9C%AA%E8%A7%A3%E5%86%B3/%E5%AD%98%E5%9C%A8bug/"/>
    
    
    <category term="未解决" scheme="https://longsizhuo123.github.io/tags/%E6%9C%AA%E8%A7%A3%E5%86%B3/"/>
    
    <category term="前端" scheme="https://longsizhuo123.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>2679.矩阵中的和</title>
    <link href="https://longsizhuo123.github.io/post/5277100.html"/>
    <id>https://longsizhuo123.github.io/post/5277100.html</id>
    <published>2023-07-04T14:27:00.000Z</published>
    <updated>2023-07-27T08:03:55.609Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h1><p><img src="../assets/img/2023-07-05.png" alt="2023-07-05.png"><br><a href="https://leetcode.cn/problems/sum-in-a-matrix/">2679.矩阵中的和.md</a></p><h1 id="思想："><a href="#思想：" class="headerlink" title="思想："></a>思想：</h1><p><strong>一行</strong><br>首先题意是找到每个子列表中最大的那个数，然后把pop出去，最后求和。<br>一次次遍历效果太差，于是我想到了用zip一次性遍历多个子数组。<br>于是先对每个子数组排序，然后用zip遍历，找到最大值。<br>举个例子：<br><code>nums = [[7,2,1],[6,4,2],[6,5,3],[3,2,1]]</code><br>排序后：<br><code>nums = [[1,2,7],[2,4,6],[3,5,6],[1,2,3]]</code><br>然后用zip遍历得到：<br><code>[(1,2,3,1),(2,4,5,2),(7,6,6,3)]</code><br>找最大值：<br><code>[3,5,7]</code><br>求和：<br><code>15</code></p><h1 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">matrixSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(<span class="built_in">max</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> \</span><br><span class="line">        <span class="built_in">zip</span>(*(<span class="built_in">sorted</span>(sublist) <span class="keyword">for</span> sublist <span class="keyword">in</span> nums)))</span><br></pre></td></tr></table></figure><h3 id="的作用以及zip-讲解"><a href="#的作用以及zip-讲解" class="headerlink" title="*的作用以及zip()讲解"></a>*的作用以及zip()讲解</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">nums = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">7</span>],[<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>],[<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums[<span class="number">1</span>])):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">        <span class="built_in">print</span>(nums[j][i])</span><br><span class="line"><span class="comment"># ans = 123124527663</span></span><br><span class="line">num1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">7</span>]</span><br><span class="line">num2 = [<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>]</span><br><span class="line">num3 = [<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">num4 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure><p><code>zip()</code>函数是将多个列表中的元素一一对应，然后返回一个zip对象，可以用list()函数转换为列表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">zip</span>(num1, num2, num3, num4):</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line"><span class="comment">#(1, 2, 3, 1)</span></span><br><span class="line"><span class="comment">#(2, 4, 5, 2)</span></span><br><span class="line"><span class="comment">#(7, 6, 6, 3)</span></span><br></pre></td></tr></table></figure><p><code>*nums</code>的作用在python中不是指针，而是将nums中的每个元素作为参数传入函数中。我在这里理解为列举。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 列举</span></span><br><span class="line"><span class="built_in">print</span>(*nums)</span><br><span class="line"><span class="comment"># [1, 2, 7] [2, 4, 6] [3, 5, 6] [1, 2, 3]</span></span><br></pre></td></tr></table></figure><p><code>zip(*nums)</code>是将nums中的每个元素作为参数传入zip()函数中，然后返回一个zip对象，可以用list()函数转换为列表。<br><code>zip(*nums)</code>等价于<code>zip(num1, num2, num3, num4)</code>，其中num1, num2, num3, num4是nums中的元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">zip</span>(*nums):</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line"><span class="comment"># 等效</span></span><br><span class="line"><span class="comment">#(1, 2, 3, 1)</span></span><br><span class="line"><span class="comment">#(2, 4, 5, 2)</span></span><br><span class="line"><span class="comment">#(7, 6, 6, 3)</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目：&quot;&gt;&lt;a href=&quot;#题目：&quot; class=&quot;headerlink&quot; title=&quot;题目：&quot;&gt;&lt;/a&gt;题目：&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;../assets/img/2023-07-05.png&quot; alt=&quot;2023-07-05.png&quot;&gt;&lt;br&gt;&lt;</summary>
      
    
    
    
    
    <category term="Python" scheme="https://longsizhuo123.github.io/tags/Python/"/>
    
    <category term="题解" scheme="https://longsizhuo123.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="数组" scheme="https://longsizhuo123.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="矩阵" scheme="https://longsizhuo123.github.io/tags/%E7%9F%A9%E9%98%B5/"/>
    
    <category term="排序" scheme="https://longsizhuo123.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
    <category term="模拟" scheme="https://longsizhuo123.github.io/tags/%E6%A8%A1%E6%8B%9F/"/>
    
    <category term="堆（优先队列）" scheme="https://longsizhuo123.github.io/tags/%E5%A0%86%EF%BC%88%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%EF%BC%89/"/>
    
  </entry>
  
</feed>
