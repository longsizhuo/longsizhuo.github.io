<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>龙龙的网站</title>
  
  
  <link href="https://longsizhuo123.github.io/atom.xml" rel="self"/>
  
  <link href="https://longsizhuo123.github.io/"/>
  <updated>2023-09-11T15:45:19.495Z</updated>
  <id>https://longsizhuo123.github.io/</id>
  
  <author>
    <name>long long</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>630.课程表III</title>
    <link href="https://longsizhuo123.github.io/post/e14241e.html"/>
    <id>https://longsizhuo123.github.io/post/e14241e.html</id>
    <published>2023-09-11T16:25:00.000Z</published>
    <updated>2023-09-11T15:45:19.495Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h1><p><img src="../assets/img/img_1.png" alt="img_1.png"></p><p><a href="https://leetcode.cn/problems/course-schedule-iii/">题目链接</a></p><h1 id="思想："><a href="#思想：" class="headerlink" title="思想："></a>思想：</h1><p>思路来自于宫水三叶的贪心 + 优先队列，</p><ol><li>首先，我们按课程的结束时间对它们进行排序。这样做的目的是尝试每个课程，看看它能否适应我们的时间表。</li><li>因为Python的heapq默认是一个最小堆，所以当我们加入一个课程时，我们使用其持续时间的负数，从而使得堆顶部始终是持续时间最长的课程。</li><li>当遍历每个课程时，尝试把它加入到我们的日程中。但是，如果我们发现加入该课程后总时间超过了该课程的结束时间，那么我们需要从我们的日程中去掉一个课程，最好去掉那个持续时间最长的课程，因为这将释放出最多的时间，这也是为什么使用一个最大堆。<br><code>sum += heapq.heappop(q)</code></li><li>Java中的<code>Arrays.sort(courses, (a,b)-&gt;a[1]-b[1]); </code>等同于Python中的<code>courses.sort(key=lambda x: x[1])</code></li></ol><p>以下引用宫水三叶解法原文，关于为什么使用greedy：</p><pre><code>题目是要我们构造出一种可行的排列，排列中每个课程的实际结束时间满足「最晚完成时间」要求，求可行排序的最大长度（每个课程对答案的贡献都是 1）。这容易引导我们往「泛化背包」方面进行思考：简单来说，对于某个物品（课程）而言，在不同条件下成本不同，在时间轴 `[1,courses[i][1]−courses[i][0]]` 上该物品可被选，成本为其持续时间，在比该范围大的数轴上无法被选，成本为正无穷。因此某一段特定的时间轴上，问题可抽象成有条件限制的组合优化问题。由于数据范围为 10^4，泛化背包做法需要记录的维度大于一维，不予考虑。再然后容易想到「二分」，显然在以最大选择数量 ans 为分割点的数组上具有「二段性」：1. 使用数量小于等于 ans 的课程能够构造出合法排序（考虑在最长合法序列上做减法即可）；2. 使用数量大于 ans 的课程无法构造出合法排列。此时二分范围为 `[0,n]`，问题转化为：如何在 `O(n)` 检查是否可构造出某个长度 len 的合法排列（实现 `check` 方法）。常规的线性扫描做法无法确定是否存在某个长度的合法排列，因此二分不予考虑。我们需要运用「贪心」思维考虑可能的方案。</code></pre><h1 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">scheduleCourse</span>(<span class="params">self, courses: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        courses.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># This will be a max-heap based on course duration</span></span><br><span class="line">        q = []</span><br><span class="line">        <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> courses:</span><br><span class="line">            d, e = c</span><br><span class="line">            <span class="built_in">sum</span> += d</span><br><span class="line">            heapq.heappush(q, -d)</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">sum</span> &gt; e:</span><br><span class="line">                <span class="built_in">sum</span> += heapq.heappop(q)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(q)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目：&quot;&gt;&lt;a href=&quot;#题目：&quot; class=&quot;headerlink&quot; title=&quot;题目：&quot;&gt;&lt;/a&gt;题目：&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;../assets/img/img_1.png&quot; alt=&quot;img_1.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href</summary>
      
    
    
    
    
    <category term="Python" scheme="https://longsizhuo123.github.io/tags/Python/"/>
    
    <category term="题解" scheme="https://longsizhuo123.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="贪心" scheme="https://longsizhuo123.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
    <category term="优先队列" scheme="https://longsizhuo123.github.io/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>GO语言# GO语言可爱捏</title>
    <link href="https://longsizhuo123.github.io/post/67fc8613.html"/>
    <id>https://longsizhuo123.github.io/post/67fc8613.html</id>
    <published>2023-07-27T08:03:55.611Z</published>
    <updated>2023-07-27T08:03:55.611Z</updated>
    
    <content type="html"><![CDATA[<p><img src="../assets/img/motorcycle.svg" alt="motorcycle.svg"></p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Hello world&quot;</span>)</span><br><span class="line">arr := []<span class="type">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line">fmt.Println(a(arr))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">a</span><span class="params">(x []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(x); i++ &#123;</span><br><span class="line"><span class="keyword">if</span> i%<span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">x[i] = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight golang"><figcaption><span>修改字符串</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="string">&quot;hello&quot;</span></span><br><span class="line">c := []<span class="type">byte</span>(s)  <span class="comment">// 将字符串 s 转换为 []byte 类型</span></span><br><span class="line">c[<span class="number">0</span>] = <span class="string">&#x27;c&#x27;</span></span><br><span class="line">s2 := <span class="type">string</span>(c)  <span class="comment">// 再转换回 string 类型</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, s2)</span><br><span class="line"></span><br><span class="line">s := <span class="string">&quot;hello&quot;</span></span><br><span class="line">s = <span class="string">&quot;c&quot;</span> + s[<span class="number">1</span>:] <span class="comment">// 字符串虽不能更改，但可进行切片操作</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, s)</span><br></pre></td></tr></table></figure><p>如果要声明一个多行的字符串怎么办？可以通过`来声明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">m := `hello</span><br><span class="line">world`</span><br></pre></td></tr></table></figure><p>` 括起的字符串为Raw字符串，即字符串在代码中的形式就是打印时的形式，它没有字符转义，换行也将原样输出</p><h1 id="错误类型"><a href="#错误类型" class="headerlink" title="错误类型"></a>错误类型</h1><p>Go内置有一个error类型，专门用来处理错误信息，Go的package里面还专门有一个包errors来处理错误：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">err := errors.New(<span class="string">&quot;emit macho dwarf: elf header corrupted&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Print(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;../assets/img/motorcycle.svg&quot; alt=&quot;motorcycle.svg&quot;&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight golang&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;sp</summary>
      
    
    
    
    
    <category term="Python" scheme="https://longsizhuo123.github.io/tags/Python/"/>
    
    <category term="题解" scheme="https://longsizhuo123.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>置顶文章</title>
    <link href="https://longsizhuo123.github.io/post/edc2b94.html"/>
    <id>https://longsizhuo123.github.io/post/edc2b94.html</id>
    <published>2023-07-27T08:03:55.611Z</published>
    <updated>2023-07-27T08:03:55.611Z</updated>
    
    <content type="html"><![CDATA[<h1 id="longsizhuo123-github-io"><a href="#longsizhuo123-github-io" class="headerlink" title="longsizhuo123.github.io"></a>longsizhuo123.github.io</h1><p><img src="https://user-images.githubusercontent.com/114939201/214082770-35d1fb45-9891-4b73-ba89-18e33030640f.png" alt="pattern_stripes-1_1_2_0-0_125_1__cc2a35_4f372d_00a1b0_edc951_eb6941"></p><p><em>“Maybe it could be a nice memory”</em></p><p>Welcome to my personal blog repository on Github! My name is Sizhuo Long, and I am currently a student in Australia. This repository is home to my personal blog, which is built using the HEXO static site generator. </p><p>On my blog, you’ll find a variety of content including my thoughts on technology, programming, and the latest developments in my field of study. I also share my experiences and lessons learned from the projects I’ve worked on. </p><p>I hope that by sharing my knowledge and insights, I can help others who are interested in the same topics. I welcome any comments and feedback, and I am always open to collaboration. </p><p><strong>Thank you for visiting my blog</strong>, I hope you will find something interesting here. And I would really appreciate it if you could pay more attention to my blog and <strong>follow me</strong>.</p><h3 id="Why-you-should-follow-me"><a href="#Why-you-should-follow-me" class="headerlink" title="Why you should follow me"></a>Why you should follow me</h3><ul><li>I’ll share my personal experiences and thoughts on technology and programming </li><li>I’ll keep you updated on the latest developments in my field of study</li><li>I’m open to collaboration and feedback.</li></ul><h3 id="How-to-contact-me"><a href="#How-to-contact-me" class="headerlink" title="How to contact me"></a>How to contact me</h3><ul><li>Email: <a href="mailto:&#x6c;&#x6f;&#x6e;&#x67;&#x73;&#105;&#x7a;&#104;&#x75;&#x6f;&#64;&#103;&#109;&#x61;&#105;&#x6c;&#46;&#99;&#x6f;&#109;">&#x6c;&#x6f;&#x6e;&#x67;&#x73;&#105;&#x7a;&#104;&#x75;&#x6f;&#64;&#103;&#109;&#x61;&#105;&#x6c;&#46;&#99;&#x6f;&#109;</a></li><li>LinkedIn: <a href="https://www.linkedin.com/in/longsizhuo/">Sizhuo Long</a></li><li>XiaoHongShu(Small RedBook): <a href="https://www.xiaohongshu.com/user/profile/5c0b8cc2000000000601e809">@sizhuo_long</a></li></ul><p>Thank you for reading, and I hope you enjoy my blog!</p><p><img src="https://user-images.githubusercontent.com/114939201/214082782-ae84027e-0a15-4ed4-843b-00a29ea19480.png" alt="pattern_stripes-1_1_2_0-0_125_1__cc2a35_4f372d_00a1b0_edc951_eb6941"></p><p><strong><a href="https://longsizhuo.shinyapps.io/long/">面向单细胞RNA数据分析工具</a></strong><br>以前做的项目，还有很多错误，勿喷。<br><strong><a href="html/Sichuan_Traveler/index.html">蜀地旅行菌</a></strong><br>这是一个本科大二的时候的一个小作业，是小组作业。一开始因为链接不了<code>html</code>文件，阅读了很多很多官方文档或者CSDN文档<br>    。最后阅读了一篇文章，说是HEXO在当你<code>generate</code>的时候，就会把source中的文件append到public中去，后来试了很多次，发现直接以<br>public为源文件夹，调用目录即可。虽然这样就会导致无法在md文档中超链接到文件。    </p><p>同时，也存在新的bug未解决：login.html无法和index.html相互跳转<br>Linkin:</p><div class="badge-base LI-profile-badge" data-locale="zh_CN" data-size="medium" data-theme="dark" data-type="HORIZONTAL" data-vanity="longsizhuo" data-version="v1"><a class="badge-base__link LI-simple-link" href="https://au.linkedin.com/in/longsizhuo?trk=profile-badge">Sizhuo Long</a></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;longsizhuo123-github-io&quot;&gt;&lt;a href=&quot;#longsizhuo123-github-io&quot; class=&quot;headerlink&quot; title=&quot;longsizhuo123.github.io&quot;&gt;&lt;/a&gt;longsizhuo123.git</summary>
      
    
    
    
    <category term="前端" scheme="https://longsizhuo123.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="HEXO" scheme="https://longsizhuo123.github.io/categories/%E5%89%8D%E7%AB%AF/HEXO/"/>
    
    <category term="未解决" scheme="https://longsizhuo123.github.io/categories/%E6%9C%AA%E8%A7%A3%E5%86%B3/"/>
    
    <category term="存在bug" scheme="https://longsizhuo123.github.io/categories/%E6%9C%AA%E8%A7%A3%E5%86%B3/%E5%AD%98%E5%9C%A8bug/"/>
    
    
    <category term="未解决" scheme="https://longsizhuo123.github.io/tags/%E6%9C%AA%E8%A7%A3%E5%86%B3/"/>
    
    <category term="前端" scheme="https://longsizhuo123.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>2679.矩阵中的和</title>
    <link href="https://longsizhuo123.github.io/post/5277100.html"/>
    <id>https://longsizhuo123.github.io/post/5277100.html</id>
    <published>2023-07-04T14:27:00.000Z</published>
    <updated>2023-07-27T08:03:55.609Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h1><p><img src="../assets/img/2023-07-05.png" alt="2023-07-05.png"><br><a href="https://leetcode.cn/problems/sum-in-a-matrix/">2679.矩阵中的和.md</a></p><h1 id="思想："><a href="#思想：" class="headerlink" title="思想："></a>思想：</h1><p><strong>一行</strong><br>首先题意是找到每个子列表中最大的那个数，然后把pop出去，最后求和。<br>一次次遍历效果太差，于是我想到了用zip一次性遍历多个子数组。<br>于是先对每个子数组排序，然后用zip遍历，找到最大值。<br>举个例子：<br><code>nums = [[7,2,1],[6,4,2],[6,5,3],[3,2,1]]</code><br>排序后：<br><code>nums = [[1,2,7],[2,4,6],[3,5,6],[1,2,3]]</code><br>然后用zip遍历得到：<br><code>[(1,2,3,1),(2,4,5,2),(7,6,6,3)]</code><br>找最大值：<br><code>[3,5,7]</code><br>求和：<br><code>15</code></p><h1 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">matrixSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(<span class="built_in">max</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> \</span><br><span class="line">        <span class="built_in">zip</span>(*(<span class="built_in">sorted</span>(sublist) <span class="keyword">for</span> sublist <span class="keyword">in</span> nums)))</span><br></pre></td></tr></table></figure><h3 id="的作用以及zip-讲解"><a href="#的作用以及zip-讲解" class="headerlink" title="*的作用以及zip()讲解"></a>*的作用以及zip()讲解</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">nums = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">7</span>],[<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>],[<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums[<span class="number">1</span>])):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">        <span class="built_in">print</span>(nums[j][i])</span><br><span class="line"><span class="comment"># ans = 123124527663</span></span><br><span class="line">num1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">7</span>]</span><br><span class="line">num2 = [<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>]</span><br><span class="line">num3 = [<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">num4 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure><p><code>zip()</code>函数是将多个列表中的元素一一对应，然后返回一个zip对象，可以用list()函数转换为列表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">zip</span>(num1, num2, num3, num4):</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line"><span class="comment">#(1, 2, 3, 1)</span></span><br><span class="line"><span class="comment">#(2, 4, 5, 2)</span></span><br><span class="line"><span class="comment">#(7, 6, 6, 3)</span></span><br></pre></td></tr></table></figure><p><code>*nums</code>的作用在python中不是指针，而是将nums中的每个元素作为参数传入函数中。我在这里理解为列举。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 列举</span></span><br><span class="line"><span class="built_in">print</span>(*nums)</span><br><span class="line"><span class="comment"># [1, 2, 7] [2, 4, 6] [3, 5, 6] [1, 2, 3]</span></span><br></pre></td></tr></table></figure><p><code>zip(*nums)</code>是将nums中的每个元素作为参数传入zip()函数中，然后返回一个zip对象，可以用list()函数转换为列表。<br><code>zip(*nums)</code>等价于<code>zip(num1, num2, num3, num4)</code>，其中num1, num2, num3, num4是nums中的元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">zip</span>(*nums):</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line"><span class="comment"># 等效</span></span><br><span class="line"><span class="comment">#(1, 2, 3, 1)</span></span><br><span class="line"><span class="comment">#(2, 4, 5, 2)</span></span><br><span class="line"><span class="comment">#(7, 6, 6, 3)</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目：&quot;&gt;&lt;a href=&quot;#题目：&quot; class=&quot;headerlink&quot; title=&quot;题目：&quot;&gt;&lt;/a&gt;题目：&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;../assets/img/2023-07-05.png&quot; alt=&quot;2023-07-05.png&quot;&gt;&lt;br&gt;&lt;</summary>
      
    
    
    
    
    <category term="Python" scheme="https://longsizhuo123.github.io/tags/Python/"/>
    
    <category term="题解" scheme="https://longsizhuo123.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="数组" scheme="https://longsizhuo123.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="矩阵" scheme="https://longsizhuo123.github.io/tags/%E7%9F%A9%E9%98%B5/"/>
    
    <category term="排序" scheme="https://longsizhuo123.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
    <category term="模拟" scheme="https://longsizhuo123.github.io/tags/%E6%A8%A1%E6%8B%9F/"/>
    
    <category term="堆（优先队列）" scheme="https://longsizhuo123.github.io/tags/%E5%A0%86%EF%BC%88%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%EF%BC%89/"/>
    
  </entry>
  
  <entry>
    <title>445.两数相加II</title>
    <link href="https://longsizhuo123.github.io/post/2c4cc46c.html"/>
    <id>https://longsizhuo123.github.io/post/2c4cc46c.html</id>
    <published>2023-07-02T17:40:00.000Z</published>
    <updated>2023-07-27T08:03:55.609Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h1><p><img src="../assets/img/2023-07-03%20(1).png" alt="2023-07-03 (1).png"><br><a href="https://leetcode.cn/problems/add-two-numbers-ii/">445.两数相加</a></p><h1 id="思想："><a href="#思想：" class="headerlink" title="思想："></a>思想：</h1><p>跟昨天的题一已，顺便找到了<br>    力扣要的是一个很奇怪的<code>precompiled.listnode.ListNode</code>，但是我的是<code>&#39;__main__.ListNode&#39;</code>。<br>原因是：重复定义了$ListNode$<br>不反转链表的方法可能就是昨天的那种，转化为数学做。<br>代码依旧是<a href="https://leetcode.cn/problems/add-two-numbers-ii/solution/fan-zhuan-lian-biao-liang-shu-xiang-jia-okw6q/">0x3f的</a><br>与昨天的题解法一样</p><h1 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseList</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="keyword">if</span> head <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> head.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        new_head = self.reverseList(head.<span class="built_in">next</span>)</span><br><span class="line">        head.<span class="built_in">next</span>.<span class="built_in">next</span> = head  <span class="comment"># 把下一个节点指向自己</span></span><br><span class="line">        head.<span class="built_in">next</span> = <span class="literal">None</span>  <span class="comment"># 断开指向下一个节点的连接，保证最终链表的末尾节点的 next 是空节点</span></span><br><span class="line">        <span class="keyword">return</span> new_head</span><br><span class="line"></span><br><span class="line">    <span class="comment"># l1 和 l2 为当前遍历的节点，carry 为进位</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">addTwo</span>(<span class="params">self, l1: <span class="type">Optional</span>[ListNode], l2: <span class="type">Optional</span>[ListNode], carry=<span class="number">0</span></span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="keyword">if</span> l1 <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> l2 <span class="keyword">is</span> <span class="literal">None</span>:  <span class="comment"># 递归边界：l1 和 l2 都是空节点</span></span><br><span class="line">            <span class="keyword">return</span> ListNode(carry) <span class="keyword">if</span> carry <span class="keyword">else</span> <span class="literal">None</span>  <span class="comment"># 如果进位了，就额外创建一个节点</span></span><br><span class="line">        <span class="keyword">if</span> l1 <span class="keyword">is</span> <span class="literal">None</span>:  <span class="comment"># 如果 l1 是空的，那么此时 l2 一定不是空节点</span></span><br><span class="line">            l1, l2 = l2, l1  <span class="comment"># 交换 l1 与 l2，保证 l1 非空，从而简化代码</span></span><br><span class="line">        carry += l1.val + (l2.val <span class="keyword">if</span> l2 <span class="keyword">else</span> <span class="number">0</span>)  <span class="comment"># 节点值和进位加在一起</span></span><br><span class="line">        l1.val = carry % <span class="number">10</span>  <span class="comment"># 每个节点保存一个数位</span></span><br><span class="line">        l1.<span class="built_in">next</span> = self.addTwo(l1.<span class="built_in">next</span>, l2.<span class="built_in">next</span> <span class="keyword">if</span> l2 <span class="keyword">else</span> <span class="literal">None</span>, carry // <span class="number">10</span>)  <span class="comment"># 进位</span></span><br><span class="line">        <span class="keyword">return</span> l1</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">addTwoNumbers</span>(<span class="params">self, l1: <span class="type">Optional</span>[ListNode], l2: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        l1 = self.reverseList(l1)</span><br><span class="line">        l2 = self.reverseList(l2)  <span class="comment"># l1 和 l2 反转后，就变成【2. 两数相加】了</span></span><br><span class="line">        l3 = self.addTwo(l1, l2)</span><br><span class="line">        <span class="keyword">return</span> self.reverseList(l3)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目：&quot;&gt;&lt;a href=&quot;#题目：&quot; class=&quot;headerlink&quot; title=&quot;题目：&quot;&gt;&lt;/a&gt;题目：&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;../assets/img/2023-07-03%20(1).png&quot; alt=&quot;2023-07-03 (1).</summary>
      
    
    
    
    
    <category term="Python" scheme="https://longsizhuo123.github.io/tags/Python/"/>
    
    <category term="题解" scheme="https://longsizhuo123.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="数学" scheme="https://longsizhuo123.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="链表" scheme="https://longsizhuo123.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
    <category term="递归" scheme="https://longsizhuo123.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
    <category term="栈" scheme="https://longsizhuo123.github.io/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>2 .两数相加</title>
    <link href="https://longsizhuo123.github.io/post/fa9db6b8.html"/>
    <id>https://longsizhuo123.github.io/post/fa9db6b8.html</id>
    <published>2023-07-02T13:19:00.000Z</published>
    <updated>2023-07-27T08:03:55.611Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h1><p><img src="../assets/img/2023-07-03.png" alt="2023-07-03.png"><br><a href="https://leetcode.cn/problems/add-two-numbers/">[2].两数相加.md</a></p><h1 id="思想："><a href="#思想：" class="headerlink" title="思想："></a>思想：</h1><p>我本来写的是最蠢的方法，把两个链表转换成数字，然后相加，再转换成链表。但是很奇怪的是我在本地运行的时候是对的，但是提交的时候就不对了，<br>力扣要的是一个很奇怪的<code>precompiled.listnode.ListNode</code>，但是我的是<code>&#39;__main__.ListNode&#39;</code>。<br>所以只能看<a href="https://leetcode.cn/problems/add-two-numbers/solution/dong-hua-jian-ji-xie-fa-cong-di-gui-dao-oe0di/">0x3f</a>的答案。</p><pre><code>每次把两个节点值`l1.val`，`l2.val`与进位值`carry`相加，除以 10 的余数即为当前节点需要保存的数位，除以10的商即为新的进位值</code></pre><p>代码实现时，有一个简化代码的小技巧：如果递归中发现<code>l2</code>的长度比<code>l1</code>更长，那么可以交换<code>l1</code>和 <code>l2</code>，保证 <code>l1</code>不是空节点，从而简化代码逻辑。</p><h1 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="comment"># l1 和 l2 为当前遍历的节点，carry 为进位</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">addTwoNumbers</span>(<span class="params">self, l1: <span class="type">Optional</span>[ListNode], l2: <span class="type">Optional</span>[ListNode], carry=<span class="number">0</span></span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="keyword">if</span> l1 <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> l2 <span class="keyword">is</span> <span class="literal">None</span>:  <span class="comment"># 递归边界：l1 和 l2 都是空节点</span></span><br><span class="line">            <span class="keyword">return</span> ListNode(carry) <span class="keyword">if</span> carry <span class="keyword">else</span> <span class="literal">None</span>  <span class="comment"># 如果进位了，就额外创建一个节点</span></span><br><span class="line">        <span class="keyword">if</span> l1 <span class="keyword">is</span> <span class="literal">None</span>:  <span class="comment"># 如果 l1 是空的，那么此时 l2 一定不是空节点</span></span><br><span class="line">            l1, l2 = l2, l1  <span class="comment"># 交换 l1 与 l2，保证 l1 非空，从而简化代码</span></span><br><span class="line">        carry += l1.val + (l2.val <span class="keyword">if</span> l2 <span class="keyword">else</span> <span class="number">0</span>)  <span class="comment"># 节点值和进位加在一起</span></span><br><span class="line">        l1.val = carry % <span class="number">10</span>  <span class="comment"># 每个节点保存一个数位</span></span><br><span class="line">        l1.<span class="built_in">next</span> = self.addTwoNumbers(l1.<span class="built_in">next</span>, l2.<span class="built_in">next</span> <span class="keyword">if</span> l2 <span class="keyword">else</span> <span class="literal">None</span>, carry // <span class="number">10</span>)  <span class="comment"># 进位</span></span><br><span class="line">        <span class="keyword">return</span> l1</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">addTwoNumbers</span>(<span class="params">self, l1: <span class="type">Optional</span>[ListNode], l2: <span class="type">Optional</span>[ListNode], carry = <span class="number">0</span></span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        l1_list = []</span><br><span class="line">        l2_list=[]</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">recursion_list</span>(<span class="params">node:ListNode, listt</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">                <span class="keyword">return</span> listt</span><br><span class="line">            listt.append(node.val)</span><br><span class="line">            <span class="keyword">return</span> recursion_list(node.<span class="built_in">next</span>, listt)</span><br><span class="line">        l1_list = recursion_list(l1, l1_list)</span><br><span class="line">        l2_list = recursion_list(l2, l2_list)</span><br><span class="line">        l1_list = <span class="string">&#x27;&#x27;</span>.join(<span class="built_in">map</span>(<span class="built_in">str</span>, l1_list))</span><br><span class="line">        l2_list = <span class="string">&#x27;&#x27;</span>.join(<span class="built_in">map</span>(<span class="built_in">str</span>, l2_list))</span><br><span class="line">        l3 = <span class="built_in">str</span>(<span class="built_in">int</span>(l1_list)+<span class="built_in">int</span>(l2_list))</span><br><span class="line">        <span class="built_in">print</span>(l3)</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">recursion_linkArray</span>(<span class="params">num</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> num:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            head = ListNode(<span class="number">0</span>)</span><br><span class="line">            current = head</span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> num:</span><br><span class="line">                current.<span class="built_in">next</span> = ListNode(<span class="built_in">int</span>(c))</span><br><span class="line">                current = current.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">return</span> head.<span class="built_in">next</span></span><br><span class="line">        head = recursion_linkArray(l3[::-<span class="number">1</span>])</span><br><span class="line">        <span class="built_in">print</span>(recursion_list(head, []))</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">type</span>(l1), <span class="built_in">type</span>(head))</span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目：&quot;&gt;&lt;a href=&quot;#题目：&quot; class=&quot;headerlink&quot; title=&quot;题目：&quot;&gt;&lt;/a&gt;题目：&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;../assets/img/2023-07-03.png&quot; alt=&quot;2023-07-03.png&quot;&gt;&lt;br&gt;&lt;</summary>
      
    
    
    
    
    <category term="Python" scheme="https://longsizhuo123.github.io/tags/Python/"/>
    
    <category term="题解" scheme="https://longsizhuo123.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="数学" scheme="https://longsizhuo123.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="链表" scheme="https://longsizhuo123.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
    <category term="递归" scheme="https://longsizhuo123.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>2490回环句</title>
    <link href="https://longsizhuo123.github.io/post/5c07686c.html"/>
    <id>https://longsizhuo123.github.io/post/5c07686c.html</id>
    <published>2023-06-30T15:57:00.000Z</published>
    <updated>2023-07-27T08:03:55.610Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h1><p><img src="../assets/img/2023-07-01.png" alt="2023-07-01.png"><br><a href="https://leetcode.cn/problems/circular-sentence/">[2490]回环句.md</a></p><h1 id="思想："><a href="#思想：" class="headerlink" title="思想："></a>思想：</h1><p>分割每个单词，然后拼接到一起（<code>123</code>拼接成<code>123123</code>），再直接判断每个单词对应的下一个单词是否满足首尾相同即可。</p><h1 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isCircularSentence</span>(<span class="params">self, sentence: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        sentence = sentence.split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        length = <span class="built_in">len</span>(sentence)</span><br><span class="line">        sentence += sentence</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, length):</span><br><span class="line">            <span class="keyword">if</span> sentence[i][-<span class="number">1</span>] != sentence[i+<span class="number">1</span>][<span class="number">0</span>]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目：&quot;&gt;&lt;a href=&quot;#题目：&quot; class=&quot;headerlink&quot; title=&quot;题目：&quot;&gt;&lt;/a&gt;题目：&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;../assets/img/2023-07-01.png&quot; alt=&quot;2023-07-01.png&quot;&gt;&lt;br&gt;&lt;</summary>
      
    
    
    
    
    <category term="Python" scheme="https://longsizhuo123.github.io/tags/Python/"/>
    
    <category term="题解" scheme="https://longsizhuo123.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="字符串" scheme="https://longsizhuo123.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>1253.重构 2 行二进制矩阵</title>
    <link href="https://longsizhuo123.github.io/post/5c98e66b.html"/>
    <id>https://longsizhuo123.github.io/post/5c98e66b.html</id>
    <published>2023-06-29T16:25:00.000Z</published>
    <updated>2023-07-27T08:03:55.610Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h1><p><a href="https://leetcode.cn/problems/reconstruct-a-2-row-binary-matrix/">[1253]重构 2 行二进制矩阵.md</a><br><img src="../assets/img/2023-06-30.png" alt="重构 2 行二进制矩阵"></p><h1 id="思想："><a href="#思想：" class="headerlink" title="思想："></a>思想：</h1><p>一开始又读错题了，以为是将<code>colsum</code>分成<code>upper</code> 和 <code>lower</code>两个数组，<br>结果是将将<code>colsum[i]</code>分成<code>upper[i]</code> 和 <code>lower[i]</code>两个数。<br>并且<code>upper[i]</code>和<code>lower[i]</code>的和等于<code>colsum[i]</code>。<br>在每一次的循环里，获取<code>colsum</code>的值，然后判断0，1，2仨种情况，0直接不管，2的话平均分配。<br>1的话，直接给当前最小的那个数组。（这里我用的<code>upper</code>和<code>lower</code>本身的参数来记录剩余数字）。<br>在最开始的时候判断<code>if sum(colsum) != upper + lower</code>， 最后判断<code>if upper + lower != 0</code>。</p><p>At first, I misunderstood the question again, thinking that it was about dividing <code>colsum</code> into two arrays, <code>upper</code> and <code>lower</code>. However, it turned out that it was about dividing <code>colsum[i]</code> into two numbers, <code>upper[i]</code> and <code>lower[i]</code>. Additionally, the sum of <code>upper[i]</code> and <code>lower[i]</code> should be equal to <code>colsum[i]</code>.<br>In each iteration, the value of <code>colsum</code> is obtained, and then three scenarios, 0, 1, and 2, are considered. If it’s 0, it is ignored. If it’s 2, the values are evenly distributed. If it’s 1, it is assigned to the array with the current minimum value (using the remaining numbers in upper and lower than parameters).<br>At the beginning, it is checked whether <code>if sum(colsum) != upper + lower</code>, and finally, it is checked whether <code>if upper + lower != 0</code>.</p><h1 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reconstructMatrix</span>(<span class="params">self, upper: <span class="built_in">int</span>, lower: <span class="built_in">int</span>, colsum: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">sum</span>(colsum) != upper + lower:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        upper_list = [<span class="number">0</span>] * <span class="built_in">len</span>(colsum)</span><br><span class="line">        lower_list = [<span class="number">0</span>] * <span class="built_in">len</span>(colsum)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(colsum)):</span><br><span class="line">            <span class="keyword">if</span> colsum[i] == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> colsum[i] == <span class="number">2</span>:</span><br><span class="line">                upper_list[i] = <span class="number">1</span></span><br><span class="line">                lower_list[i] = <span class="number">1</span></span><br><span class="line">                upper -= <span class="number">1</span></span><br><span class="line">                lower -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> upper &gt;= lower:</span><br><span class="line">                    upper_list[i] = <span class="number">1</span></span><br><span class="line">                    upper -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    lower_list[i] = <span class="number">1</span></span><br><span class="line">                    lower -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> upper != <span class="number">0</span> <span class="keyword">or</span> lower != <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">return</span> [upper_list, lower_list]</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目：&quot;&gt;&lt;a href=&quot;#题目：&quot; class=&quot;headerlink&quot; title=&quot;题目：&quot;&gt;&lt;/a&gt;题目：&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/reconstruct-a-2-row-binary-m</summary>
      
    
    
    
    
    <category term="Python" scheme="https://longsizhuo123.github.io/tags/Python/"/>
    
    <category term="题解" scheme="https://longsizhuo123.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="数组" scheme="https://longsizhuo123.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="矩阵" scheme="https://longsizhuo123.github.io/tags/%E7%9F%A9%E9%98%B5/"/>
    
    <category term="贪心" scheme="https://longsizhuo123.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
    <category term="中等" scheme="https://longsizhuo123.github.io/tags/%E4%B8%AD%E7%AD%89/"/>
    
  </entry>
  
  <entry>
    <title>538.把二叉搜索树转换为累加树</title>
    <link href="https://longsizhuo123.github.io/post/32401b69.html"/>
    <id>https://longsizhuo123.github.io/post/32401b69.html</id>
    <published>2023-06-04T08:50:00.000Z</published>
    <updated>2023-07-27T08:03:55.609Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h1><p>“””</p><p>给出二叉<strong> 搜索 </strong>树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 <code>node</code>&nbsp;的新值等于原树中大于或等于&nbsp;<code>node.val</code>&nbsp;的值之和。</p><p>提醒一下，二叉搜索树满足下列约束条件：</p><ul>  <li>节点的左子树仅包含键<strong> 小于 </strong>节点键的节点。</li>  <li>节点的右子树仅包含键<strong> 大于</strong> 节点键的节点。</li>  <li>左右子树也必须是二叉搜索树。</li> </ul><p><strong>注意：</strong>本题和 1038:&nbsp;<a href="https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/">https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/</a> 相同</p><p>&nbsp;</p><p><strong>示例 1：</strong></p><p><strong><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/05/03/tree.png" style="height: 364px; width: 534px;" /></strong></p><pre><strong>输入：</strong>[4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]<strong>输出：</strong>[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]</pre><p><strong>示例 2：</strong></p><pre><strong>输入：</strong>root = [0,null,1]<strong>输出：</strong>[1,null,1]</pre><p><strong>示例 3：</strong></p><pre><strong>输入：</strong>root = [1,0,2]<strong>输出：</strong>[3,3,2]</pre><p><strong>示例 4：</strong></p><pre><strong>输入：</strong>root = [3,2,4,1]<strong>输出：</strong>[7,9,4,10]</pre><p>&nbsp;</p><p><strong>提示：</strong></p><ul>  <li>树中的节点数介于 <code>0</code>&nbsp;和 <code>10<sup>4</sup></code><sup>&nbsp;</sup>之间。</li>  <li>每个节点的值介于 <code>-10<sup>4</sup></code>&nbsp;和&nbsp;<code>10<sup>4</sup></code>&nbsp;之间。</li>  <li>树中的所有值 <strong>互不相同</strong> 。</li>  <li>给定的树为二叉搜索树。</li> </ul><div><div>Related Topics</div><div><li>树</li><li>深度优先搜索</li><li>二叉搜索树</li><li>二叉树</li></div></div><br><div><li>👍 904</li><li>👎 0</li></div>"""<h1 id="思想："><a href="#思想：" class="headerlink" title="思想："></a>思想：</h1><p>方法一：反序中序遍历<br>思路及算法</p><p>本题中要求我们将每个节点的值修改为原来的节点值加上所有大于它的节点值之和。这样我们只需要反序中序遍历该二叉搜索树，记录过程中的节点值之和，并不断更新当前遍历到的节点的节点值，即可得到题目要求的累加树。</p><p>方法二：Morris 遍历<br>思路及算法</p><p>有一种巧妙的方法可以在线性时间内，只占用常数空间来实现中序遍历。这种方法由 J. H. Morris 在 1979 年的论文「Traversing Binary Trees Simply and Cheaply」中首次提出，因此被称为 Morris 遍历。</p><p>我们以一个简单的二叉树为例进行说明。假设我们要进行中序遍历的 Morris 遍历。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">    1</span></span><br><span class="line"><span class="code">   / \</span></span><br><span class="line"><span class="code">  2   3</span></span><br><span class="line"><span class="code"> / \</span></span><br><span class="line"><span class="code">4   5</span></span><br><span class="line"><span class="code"></span></span><br></pre></td></tr></table></figure><ol><li><p>初始化当前节点为根节点（current = 1）。</p></li><li><p>当前节点不为空时，执行以下步骤：</p><ol><li><p>当前节点的左子节点不为空。我们找到当前节点的前驱节点，也就是左子树中的最右节点。在这个例子中，前驱节点为节点5。</p></li><li><p>前驱节点的右子节点为空，将其右子节点指向当前节点（5 -&gt; 1）。</p></li><li><p>将当前节点移动到其左子节点（current = 2）。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line"> \</span><br><span class="line">  2</span><br><span class="line"> / \</span><br><span class="line">4   5</span><br></pre></td></tr></table></figure></li><li><p>当前节点的左子节点不为空。我们找到当前节点的前驱节点，也就是左子树中的最右节点。在这个例子中，前驱节点为节点4。</p></li><li><p>前驱节点的右子节点为空，将其右子节点指向当前节点（4 -&gt; 2）。</p></li><li><p>将当前节点移动到其左子节点（current = 4）。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line"> \</span><br><span class="line">  2</span><br><span class="line">   \</span><br><span class="line"><span class="code">    4</span></span><br><span class="line"><span class="code">     \</span></span><br><span class="line"><span class="code">      5</span></span><br><span class="line"><span class="code">    </span></span><br></pre></td></tr></table></figure></li><li><p>当前节点的左子节点为空。输出当前节点的值（4）。</p></li><li><p>将当前节点移动到其右子节点（current = 5）。</p></li><li><p>当前节点的左子节点为空。输出当前节点的值（5）。</p></li><li><p>将当前节点移动到其右子节点（current = 2）。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line"> \</span><br><span class="line">  2</span><br><span class="line">   \</span><br><span class="line"><span class="code">    4</span></span><br></pre></td></tr></table></figure></li><li><p>当前节点的左子节点为空。输出当前节点的值（2）。</p></li><li><p>将当前节点移动到其右子节点（current = 1）。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line"> \</span><br><span class="line">  2</span><br></pre></td></tr></table></figure></li><li><p>当前节点的左子节点为空。输出当前节点的值（1）。</p></li><li><p>将当前节点移动到其右子节点（current = 3）。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line"> \</span><br><span class="line">  2</span><br></pre></td></tr></table></figure></li><li><p>当前节点的左子节点为空。输出当前节点的值（3）。</p></li><li><p>将当前节点移动到其右子节点（current = null）。</p></li></ol></li><li><p>当前节点为空，遍历结束。</p></li><li><p>根据上述步骤，通过修改节点之间的指针关系，我们完成了对二叉树的中序遍历。</p></li></ol><h1 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h1><figure class="highlight python"><figcaption><span>中序遍历</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">convertBST</span>(<span class="params">self, root: TreeNode</span>) -&gt; TreeNode:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">root: TreeNode</span>):</span><br><span class="line">            <span class="keyword">nonlocal</span> total</span><br><span class="line">            <span class="keyword">if</span> root:</span><br><span class="line">                dfs(root.right)</span><br><span class="line">                total += root.val</span><br><span class="line">                root.val = total</span><br><span class="line">                dfs(root.left)</span><br><span class="line">        </span><br><span class="line">        total = <span class="number">0</span></span><br><span class="line">        dfs(root)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><figure class="highlight python"><figcaption><span>Morris遍历</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">convertBST</span>(<span class="params">self, root: TreeNode</span>) -&gt; TreeNode:</span><br><span class="line">        <span class="comment"># 获取给定节点的后继节点（中序遍历中的下一个节点）</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">getSuccessor</span>(<span class="params">node: TreeNode</span>) -&gt; TreeNode:</span><br><span class="line">            succ = node.right</span><br><span class="line">            <span class="keyword">while</span> succ.left <span class="keyword">and</span> succ.left != node:</span><br><span class="line">                succ = succ.left</span><br><span class="line">            <span class="keyword">return</span> succ</span><br><span class="line">        </span><br><span class="line">        total = <span class="number">0</span>  <span class="comment"># 记录累加的节点值之和</span></span><br><span class="line">        node = root  <span class="comment"># 当前节点初始化为根节点</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> node:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node.right:  <span class="comment"># 如果当前节点的右子节点为空</span></span><br><span class="line">                total += node.val  <span class="comment"># 将当前节点的值加到累加值中</span></span><br><span class="line">                node.val = total  <span class="comment"># 更新当前节点的值为累加值</span></span><br><span class="line">                node = node.left  <span class="comment"># 将当前节点移动到其左子节点</span></span><br><span class="line">            <span class="keyword">else</span>:  <span class="comment"># 如果当前节点的右子节点不为空</span></span><br><span class="line">                succ = getSuccessor(node)  <span class="comment"># 获取当前节点的后继节点</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> succ.left:  <span class="comment"># 如果后继节点的左子节点为空</span></span><br><span class="line">                    succ.left = node  <span class="comment"># 将后继节点的左子节点指向当前节点，建立线索</span></span><br><span class="line">                    node = node.right  <span class="comment"># 将当前节点移动到其右子节点</span></span><br><span class="line">                <span class="keyword">else</span>:  <span class="comment"># 如果后继节点的左子节点不为空</span></span><br><span class="line">                    succ.left = <span class="literal">None</span>  <span class="comment"># 将后继节点的左子节点置为空，移除线索</span></span><br><span class="line">                    total += node.val  <span class="comment"># 将当前节点的值加到累加值中</span></span><br><span class="line">                    node.val = total  <span class="comment"># 更新当前节点的值为累加值</span></span><br><span class="line">                    node = node.left  <span class="comment"># 将当前节点移动到其左子节点</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root  <span class="comment"># 返回根节点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">convertBST</span>(<span class="params">self, root: TreeNode</span>) -&gt; TreeNode:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">convert</span>(<span class="params">node: TreeNode, total: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">                <span class="keyword">return</span> total</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 递归遍历右子树</span></span><br><span class="line">            total = convert(node.right, total)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 更新节点值为累加值</span></span><br><span class="line">            total += node.val</span><br><span class="line">            node.val = total</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 递归遍历左子树</span></span><br><span class="line">            total = convert(node.left, total)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> total</span><br><span class="line"></span><br><span class="line">        convert(root, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目：&quot;&gt;&lt;a href=&quot;#题目：&quot; class=&quot;headerlink&quot; title=&quot;题目：&quot;&gt;&lt;/a&gt;题目：&lt;/h1&gt;&lt;p&gt;“””&lt;/p&gt;
&lt;p&gt;给出二叉&lt;strong&gt; 搜索 &lt;/strong&gt;树的根节点，该树的节点值各不相同，请你将其转换为累加树（Gr</summary>
      
    
    
    
    
    <category term="Python" scheme="https://longsizhuo123.github.io/tags/Python/"/>
    
    <category term="题解" scheme="https://longsizhuo123.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="二叉树" scheme="https://longsizhuo123.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>142.环形链表II</title>
    <link href="https://longsizhuo123.github.io/post/e2c9cca9.html"/>
    <id>https://longsizhuo123.github.io/post/e2c9cca9.html</id>
    <published>2023-04-09T18:47:00.000Z</published>
    <updated>2023-07-27T08:03:55.607Z</updated>
    
    <content type="html"><![CDATA[<p><img src="../assets/img/2023-07-01%20(1).png" alt="2023-07-01 (1).png"><br><a href="https://leetcode.cn/problems/linked-list-cycle-ii/">142.环形列表II.md</a></p><h1 id="思想："><a href="#思想：" class="headerlink" title="思想："></a>思想：</h1><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h3><p>这类链表题目一般都是使用双指针法解决的，例如寻找距离尾部第 K 个节点、寻找环入口、寻找公共尾部入口等。</p><h3 id="算法流程："><a href="#算法流程：" class="headerlink" title="算法流程："></a>算法流程：</h3><ol><li><p>双指针第一次相遇： 设两指针 fast，slow 指向链表头部 head，fast 每轮走 2 步，slow 每轮走 1 步；</p><p> a. 第一种结果： fast 指针走过链表末端，说明链表无环，直接返回 null；</p><p> .TIPS: 若有环，两指针一定会相遇。因为每走 1 轮，fast 与 slow 的间距 +1，fast 终会追上 slow；<br> b. 第二种结果： 当fast == slow时， 两指针在环中 第一次相遇 。下面分析此时fast 与 slow走过的 步数关系 ：</p><p> .设链表共有 a+b 个节点，其中 链表头部到链表入口 有 a 个节点（不计链表入口节点）， 链表环 有 b 个节点（这里需要注意，a 和 b 是未知数，例如图解上链表 a=4 , b=5）；设两指针分别走了 f，s 步，则有：<br> a. fast 走的步数是slow步数的 2 倍，即 f=2s；（解析： fast 每轮走 2 步）<br> b.fast 比 slow多走了 n 个环的长度，即 f=s+nb；（ 解析： 双指针都走过 a 步，然后在环内绕圈直到重合，重合时 fast 比 slow 多走 环的长度整数倍 ）；<br> .以上两式相减得：f=2nb，s=nb，即fast和slow 指针分别走了 2n，n 个 环的周长 （注意： n 是未知数，不同链表的情况不同）。</p></li></ol><span id="more"></span><ol start="2"><li><p>目前情况分析：</p><p> .如果让指针从链表头部一直向前走并统计步数k，那么所有 走到链表入口节点时的步数 是：k=a+nb（先走 a 步到入口节点，之后每绕 1 圈环（ b 步）都会再次到入口节点）。</p><p> ..而目前，slow 指针走过的步数为 nb 步。因此，我们只要想办法让 slow 再走 a 步停下来，就可以到环的入口。</p><p>…但是我们不知道 a 的值，该怎么办？依然是使用双指针法。我们构建一个指针，此指针需要有以下性质：此指针和slow 一起向前走 a 步后，两者在入口节点重合。那么从哪里走到入口节点需要 a 步？答案是链表头部head。</p></li><li><p>双指针第二次相遇：<br> .slow指针 位置不变 ，将fast指针重新 指向链表头部节点 ；slow和fast同时每轮向前走 1 步；</p><p> ..TIPS：此时 f=0，s=nb ；<br> …当 fast 指针走到f=a 步时，slow 指针走到步s=a+nb，此时 两指针重合，并同时指向链表环入口 。</p></li><li><p>返回slow指针指向的节点。</p></li></ol><h3 id="复杂度分析："><a href="#复杂度分析：" class="headerlink" title="复杂度分析："></a>复杂度分析：</h3><p>时间复杂度 O(N) ：第二次相遇中，慢指针须走步数 a&lt;a+b；第一次相遇中，慢指针须走步数 a+b−x&lt;a+b，其中 x 为双指针重合点与环入口距离；因此总体为线性复杂度；<br>空间复杂度 O(1) ：双指针使用常数大小的额外空间。<br><img src="../photos/circle link array 2/Picture1.png" alt="Picture1.png" width="50%" height="50%"><br><img src="../photos/circle link array 2/Picture2.png" alt="Picture2.png" width="50%" height="50%"><br><img src="../photos/circle link array 2/Picture3.png" alt="Picture3.png" width="50%" height="50%"><br><img src="../photos/circle link array 2/Picture4.png" alt="Picture4.png" width="50%" height="50%"><br><img src="../photos/circle link array 2/Picture5.png" alt="Picture5.png" width="50%" height="50%"><br><img src="../photos/circle link array 2/Picture6.png" alt="Picture6.png" width="50%" height="50%"><br><img src="../photos/circle link array 2/Picture7.png" alt="Picture7.png" width="50%" height="50%"><br><img src="../photos/circle link array 2/Picture8.png" alt="Picture8.png" width="50%" height="50%"><br><img src="../photos/circle link array 2/Picture9.png" alt="Picture9.png" width="50%" height="50%"><br><img src="../photos/circle link array 2/Picture10.png" alt="Picture10.png" width="50%" height="50%"><br><img src="../photos/circle link array 2/Picture11.png" alt="Picture11.png" width="50%" height="50%"></p><h1 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">detectCycle</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        a = head</span><br><span class="line">        b = head</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> b <span class="keyword">or</span> <span class="keyword">not</span> b.<span class="built_in">next</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            a = a.<span class="built_in">next</span></span><br><span class="line">            b = b.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">if</span> b == a:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        b = head</span><br><span class="line">        <span class="keyword">while</span> a != b:</span><br><span class="line">            a, b = a.<span class="built_in">next</span>, b.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> b</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode *a = head;</span><br><span class="line">        ListNode *b = head;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!b <span class="keyword">or</span> !b-&gt;next) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            a = a-&gt;next;</span><br><span class="line">            b = b-&gt;next-&gt;next;</span><br><span class="line">            <span class="comment">//因为b每次走两步，所以ab必定相遇</span></span><br><span class="line">            <span class="keyword">if</span> (a == b) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 相遇后a在原地等b, b去链表头部</span></span><br><span class="line">        b = head;</span><br><span class="line">        <span class="keyword">while</span>(a!=b)&#123;</span><br><span class="line">            a = a-&gt;next;</span><br><span class="line">            b = b-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;../assets/img/2023-07-01%20(1).png&quot; alt=&quot;2023-07-01 (1).png&quot;&gt;&lt;br&gt;&lt;a href=&quot;https://leetcode.cn/problems/linked-list-cycle-ii/&quot;&gt;142.环形列表II.md&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;思想：&quot;&gt;&lt;a href=&quot;#思想：&quot; class=&quot;headerlink&quot; title=&quot;思想：&quot;&gt;&lt;/a&gt;思想：&lt;/h1&gt;&lt;h3 id=&quot;解题思路：&quot;&gt;&lt;a href=&quot;#解题思路：&quot; class=&quot;headerlink&quot; title=&quot;解题思路：&quot;&gt;&lt;/a&gt;解题思路：&lt;/h3&gt;&lt;p&gt;这类链表题目一般都是使用双指针法解决的，例如寻找距离尾部第 K 个节点、寻找环入口、寻找公共尾部入口等。&lt;/p&gt;
&lt;h3 id=&quot;算法流程：&quot;&gt;&lt;a href=&quot;#算法流程：&quot; class=&quot;headerlink&quot; title=&quot;算法流程：&quot;&gt;&lt;/a&gt;算法流程：&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;双指针第一次相遇： 设两指针 fast，slow 指向链表头部 head，fast 每轮走 2 步，slow 每轮走 1 步；&lt;/p&gt;
&lt;p&gt; a. 第一种结果： fast 指针走过链表末端，说明链表无环，直接返回 null；&lt;/p&gt;
&lt;p&gt; .TIPS: 若有环，两指针一定会相遇。因为每走 1 轮，fast 与 slow 的间距 +1，fast 终会追上 slow；&lt;br&gt; b. 第二种结果： 当fast == slow时， 两指针在环中 第一次相遇 。下面分析此时fast 与 slow走过的 步数关系 ：&lt;/p&gt;
&lt;p&gt; .设链表共有 a+b 个节点，其中 链表头部到链表入口 有 a 个节点（不计链表入口节点）， 链表环 有 b 个节点（这里需要注意，a 和 b 是未知数，例如图解上链表 a=4 , b=5）；设两指针分别走了 f，s 步，则有：&lt;br&gt; a. fast 走的步数是slow步数的 2 倍，即 f=2s；（解析： fast 每轮走 2 步）&lt;br&gt; b.fast 比 slow多走了 n 个环的长度，即 f=s+nb；（ 解析： 双指针都走过 a 步，然后在环内绕圈直到重合，重合时 fast 比 slow 多走 环的长度整数倍 ）；&lt;br&gt; .以上两式相减得：f=2nb，s=nb，即fast和slow 指针分别走了 2n，n 个 环的周长 （注意： n 是未知数，不同链表的情况不同）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    
    <category term="Python" scheme="https://longsizhuo123.github.io/tags/Python/"/>
    
    <category term="题解" scheme="https://longsizhuo123.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>19.删除链表的倒数第N个节点</title>
    <link href="https://longsizhuo123.github.io/post/c916b663.html"/>
    <id>https://longsizhuo123.github.io/post/c916b663.html</id>
    <published>2023-04-09T18:37:00.000Z</published>
    <updated>2023-07-27T08:03:55.608Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h1><p>给你一个链表，删除链表的倒数第&nbsp;<code>n</code><em>&nbsp;</em>个结点，并且返回链表的头结点。</p><p>&nbsp;</p><p><strong>示例 1：</strong></p> <img alt="" src="https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg" style="width: 542px; height: 222px;" /> <pre><strong>输入：</strong>head = [1,2,3,4,5], n = 2<strong>输出：</strong>[1,2,3,5]</pre><p><strong>示例 2：</strong></p><pre><strong>输入：</strong>head = [1], n = 1<strong>输出：</strong>[]</pre><p><strong>示例 3：</strong></p><pre><strong>输入：</strong>head = [1,2], n = 1<strong>输出：</strong>[1]</pre><p>&nbsp;</p><p><strong>提示：</strong></p><ul>  <li>链表中结点的数目为 <code>sz</code></li>  <li><code>1 &lt;= sz &lt;= 30</code></li>  <li><code>0 &lt;= Node.val &lt;= 100</code></li>  <li><code>1 &lt;= n &lt;= sz</code></li> </ul><p>&nbsp;</p><p><strong>进阶：</strong>你能尝试使用一趟扫描实现吗？</p><div><div>Related Topics</div><div><li>链表</li><li>双指针</li></div></div><br><div><li>👍 2500</li><li>👎 0</li></div><p><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/">19.删除链表的倒数第N个节点.md</a></p><h1 id="思想："><a href="#思想：" class="headerlink" title="思想："></a>思想：</h1><p>采取双重遍历肯定是可以解决问题的，但题目要求我们一次遍历解决问题，那我们的思路得发散一下。</p><p>我们可以设想假设设定了双指针 p 和 q 的话，当 q 指向末尾的 NULL，p 与 q 之间相隔的元素个数为 n 时，那么删除掉 p 的下一个指针就完成了要求。</p><p>设置虚拟节点 dummyHead 指向 head<br>设定双指针 p 和 q，初始都指向虚拟节点 dummyHead<br>移动 q，直到 p 与 q 之间相隔的元素个数为 n<br>同时移动 p 与 q，直到 q 指向的为 NULL<br>将 p 的下一个节点指向下下个节点</p><h1 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeNthFromEnd</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode], n: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        dummyHead = ListNode(val=<span class="number">0</span>, <span class="built_in">next</span>=head)</span><br><span class="line">        head = tail = dummyHead</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            tail = tail.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">while</span> tail.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            head, tail = head.<span class="built_in">next</span>, tail.<span class="built_in">next</span></span><br><span class="line">        head.<span class="built_in">next</span> = head.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dummyHead.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode *yummyNode = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        yummyNode-&gt;next = head;</span><br><span class="line">        ListNode *fast = yummyNode;</span><br><span class="line">        ListNode *slow = yummyNode;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (slow-&gt;next != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//回收内存</span></span><br><span class="line">        ListNode *del = fast-&gt;next;</span><br><span class="line">        fast-&gt;next = del-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> del;</span><br><span class="line">        <span class="comment">//返回头节点</span></span><br><span class="line">        ListNode *ret = yummyNode-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> yummyNode;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目：&quot;&gt;&lt;a href=&quot;#题目：&quot; class=&quot;headerlink&quot; title=&quot;题目：&quot;&gt;&lt;/a&gt;题目：&lt;/h1&gt;&lt;p&gt;给你一个链表，删除链表的倒数第&amp;nbsp;&lt;code&gt;n&lt;/code&gt;&lt;em&gt;&amp;nbsp;&lt;/em&gt;个结点，并且返回链表的头结点。&lt;</summary>
      
    
    
    
    
    <category term="Python" scheme="https://longsizhuo123.github.io/tags/Python/"/>
    
    <category term="题解" scheme="https://longsizhuo123.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>24.两两交换链表</title>
    <link href="https://longsizhuo123.github.io/post/d030a5a0.html"/>
    <id>https://longsizhuo123.github.io/post/d030a5a0.html</id>
    <published>2023-04-09T18:30:00.000Z</published>
    <updated>2023-07-27T08:03:55.609Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h1><p>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。</p><p> </p><p><strong>示例 1：</strong></p> <img alt="" src="https://assets.leetcode.com/uploads/2020/10/03/swap_ex1.jpg" style="width: 422px; height: 222px;" /> <pre><strong>输入：</strong>head = [1,2,3,4]<strong>输出：</strong>[2,1,4,3]</pre><p><strong>示例 2：</strong></p><pre><strong>输入：</strong>head = []<strong>输出：</strong>[]</pre><p><strong>示例 3：</strong></p><pre><strong>输入：</strong>head = [1]<strong>输出：</strong>[1]</pre><p> </p><p><strong>提示：</strong></p><ul>  <li>链表中节点的数目在范围 <code>[0, 100]</code> 内</li>  <li><code>0 <= Node.val <= 100</code></li> </ul><div><div>Related Topics</div><div><li>递归</li><li>链表</li></div></div><br><div><li>👍 1785</li><li>👎 0</li></div><p><a href="https://leetcode.cn/problems/swap-nodes-in-pairs/description/">24.两两交换链表.md</a></p><h1 id="思想："><a href="#思想：" class="headerlink" title="思想："></a>思想：</h1><p>用 head 表示原始链表的头节点，新的链表的第二个节点，用 newHead 表示新的链表的头节点，原始链表的第二个节点，则原始链表中的其余节点的头节点是 newHead.next。令 head.next = swapPairs(newHead.next)，表示将其余节点进行两两交换，交换后的新的头节点为 head 的下一个节点。然后令 newHead.next = head，即完成了所有节点的交换。最后返回新的链表的头节点 newHead。<br><img src="../photos/%EF%BF%BD%DD%B9%EF%BF%BD.gif" alt="递归.gif"></p><h1 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">swapPairs</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.<span class="built_in">next</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        virtual_head = head.<span class="built_in">next</span></span><br><span class="line">        head.<span class="built_in">next</span> = self.swapPairs(virtual_head.<span class="built_in">next</span>)</span><br><span class="line">        virtual_head.<span class="built_in">next</span> = head</span><br><span class="line">        <span class="keyword">return</span> virtual_head</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span> <span class="keyword">or</span> head-&gt;next == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *yummyNode = head-&gt;next;</span><br><span class="line">        head-&gt;next = <span class="built_in">swapPairs</span>(yummyNode-&gt;next);</span><br><span class="line">        yummyNode-&gt;next = head;</span><br><span class="line">        <span class="keyword">return</span> yummyNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目：&quot;&gt;&lt;a href=&quot;#题目：&quot; class=&quot;headerlink&quot; title=&quot;题目：&quot;&gt;&lt;/a&gt;题目：&lt;/h1&gt;&lt;p&gt;给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。</summary>
      
    
    
    
    
    <category term="Python" scheme="https://longsizhuo123.github.io/tags/Python/"/>
    
    <category term="题解" scheme="https://longsizhuo123.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>1017.负二进制转换</title>
    <link href="https://longsizhuo123.github.io/post/80cafdc8.html"/>
    <id>https://longsizhuo123.github.io/post/80cafdc8.html</id>
    <published>2023-04-06T15:01:00.000Z</published>
    <updated>2023-07-27T08:03:55.607Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h1><p>给你一个整数 <code>n</code> ，以二进制字符串的形式返回该整数的 <strong>负二进制（<code>base -2</code>）</strong>表示。</p><p><strong>注意，</strong>除非字符串就是&nbsp;<code>"0"</code>，否则返回的字符串中不能含有前导零。</p><p>&nbsp;</p><p><strong>示例 1：</strong></p><pre><strong>输入：</strong>n = 2<strong>输出：</strong>"110"<strong>解释：</strong>(-2)<sup>2</sup> + (-2)<sup>1</sup> = 2</pre><p><strong>示例 2：</strong></p><pre><strong>输入：</strong>n = 3<strong>输出：</strong>"111"<strong>解释：</strong>(-2)<sup>2</sup> + (-2)<sup>1</sup> + (-2)<sup>0</sup> = 3</pre><p><strong>示例 3：</strong></p><pre><strong>输入：</strong>n = 4<strong>输出：</strong>"100"<strong>解释：</strong>(-2)<sup>2</sup> = 4</pre><p>&nbsp;</p><p><strong>提示：</strong></p><ul>  <li><code>0 &lt;= n &lt;= 10<sup>9</sup></code></li> </ul><div><div>Related Topics</div><div><li>数学</li></div></div><br><div><li>👍 111</li><li>👎 0</li></div>[1017.负二进制转换.md]()<h1 id="思想："><a href="#思想：" class="headerlink" title="思想："></a>思想：</h1><p>我们可以判断 n 从低位到高位的每一位，如果该位为 1，那么答案的该位为 1，否则为 0。如果该位为 1，那么我们需要将 n 减去 k。接下来我们更新 n=⌊n/2⌋, k=−k。继续判断下一位。<br>最后，我们将答案反转后返回即可。<br>时间复杂度 O(logn)，其中 n 为给定的整数。忽略答案的空间消耗，空间复杂度 O(1)。</p><h1 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">baseNeg2</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        k = <span class="number">1</span></span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">while</span> n:</span><br><span class="line">            <span class="keyword">if</span> n % <span class="number">2</span>:</span><br><span class="line">                ans.append(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">                n -= k</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ans.append(<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">            n //= <span class="number">2</span></span><br><span class="line">            k *= -<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(ans[::-<span class="number">1</span>]) <span class="keyword">or</span> <span class="string">&#x27;0&#x27;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目：&quot;&gt;&lt;a href=&quot;#题目：&quot; class=&quot;headerlink&quot; title=&quot;题目：&quot;&gt;&lt;/a&gt;题目：&lt;/h1&gt;&lt;p&gt;给你一个整数 &lt;code&gt;n&lt;/code&gt; ，以二进制字符串的形式返回该整数的 &lt;strong&gt;负二进制（&lt;code&gt;base -2</summary>
      
    
    
    
    
    <category term="Python" scheme="https://longsizhuo123.github.io/tags/Python/"/>
    
    <category term="题解" scheme="https://longsizhuo123.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>977.有序数组的平方</title>
    <link href="https://longsizhuo123.github.io/post/a386fcdc.html"/>
    <id>https://longsizhuo123.github.io/post/a386fcdc.html</id>
    <published>2023-04-06T14:39:00.000Z</published>
    <updated>2023-07-27T08:03:55.610Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h1><p>给你一个按 <strong>非递减顺序</strong> 排序的整数数组 <code>nums</code>，返回 <strong>每个数字的平方</strong> 组成的新数组，要求也按 <strong>非递减顺序</strong> 排序。</p><ul> </ul><p>&nbsp;</p><p><strong>示例 1：</strong></p><pre><strong>输入：</strong>nums = [-4,-1,0,3,10]<strong>输出：</strong>[0,1,9,16,100]<strong>解释：</strong>平方后，数组变为 [16,1,0,9,100]排序后，数组变为 [0,1,9,16,100]</pre><p><strong>示例 2：</strong></p><pre><strong>输入：</strong>nums = [-7,-3,2,3,11]<strong>输出：</strong>[4,9,9,49,121]</pre><p>&nbsp;</p><p><strong>提示：</strong></p><ul>  <li><code><span>1 &lt;= nums.length &lt;= </span>10<sup>4</sup></code></li>  <li><code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>  <li><code>nums</code> 已按 <strong>非递减顺序</strong> 排序</li> </ul><p>&nbsp;</p><p><strong>进阶：</strong></p><ul>  <li>请你<span style="color: rgb(36, 41, 46); font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;; font-size: 14px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); text-decoration-style: initial; text-decoration-color: initial; display: inline !important; float: none;">设计时间复杂度为 <code>O(n)</code> 的算法解决本问题</span></li> </ul><div><div>Related Topics</div><div><li>数组</li><li>双指针</li><li>排序</li></div></div><br><div><li>👍 777</li><li>👎 0</li></div>[977.有序数组的平方.md]()<h1 id="思想："><a href="#思想：" class="headerlink" title="思想："></a>思想：</h1><p>本来打算每一次计算完平方数后都自己写个插排的，结果超时了。忽略了sort的牛逼。</p><h1 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sortedSquares</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        nu = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            nu.append(i * i)</span><br><span class="line">        nu.sort()</span><br><span class="line">        <span class="keyword">return</span> nu</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目：&quot;&gt;&lt;a href=&quot;#题目：&quot; class=&quot;headerlink&quot; title=&quot;题目：&quot;&gt;&lt;/a&gt;题目：&lt;/h1&gt;&lt;p&gt;给你一个按 &lt;strong&gt;非递减顺序&lt;/strong&gt; 排序的整数数组 &lt;code&gt;nums&lt;/code&gt;，返回 &lt;strong&gt;</summary>
      
    
    
    
    
    <category term="Python" scheme="https://longsizhuo123.github.io/tags/Python/"/>
    
    <category term="题解" scheme="https://longsizhuo123.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>209.长度最小的子数组</title>
    <link href="https://longsizhuo123.github.io/post/e6227611.html"/>
    <id>https://longsizhuo123.github.io/post/e6227611.html</id>
    <published>2023-04-06T14:34:00.000Z</published>
    <updated>2023-07-27T08:03:55.608Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h1><p>给定一个含有&nbsp;<code>n</code><strong>&nbsp;</strong>个正整数的数组和一个正整数 <code>target</code><strong> 。</strong></p><p>找出该数组中满足其和<strong> </strong><code>≥ target</code><strong> </strong>的长度最小的 <strong>连续子数组</strong>&nbsp;<code>[nums<sub>l</sub>, nums<sub>l+1</sub>, ..., nums<sub>r-1</sub>, nums<sub>r</sub>]</code> ，并返回其长度<strong>。</strong>如果不存在符合条件的子数组，返回 <code>0</code> 。</p><p>&nbsp;</p><p><strong>示例 1：</strong></p><pre><strong>输入：</strong>target = 7, nums = [2,3,1,2,4,3]<strong>输出：</strong>2<strong>解释：</strong>子数组&nbsp;<span><code>[4,3]</code></span>&nbsp;是该条件下的长度最小的子数组。</pre><p><strong>示例 2：</strong></p><pre><strong>输入：</strong>target = 4, nums = [1,4,4]<strong>输出：</strong>1</pre><p><strong>示例 3：</strong></p><pre><strong>输入：</strong>target = 11, nums = [1,1,1,1,1,1,1,1]<strong>输出：</strong>0</pre><p>&nbsp;</p><p><strong>提示：</strong></p><ul>  <li><code>1 &lt;= target &lt;= 10<sup>9</sup></code></li>  <li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>  <li><code>1 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li> </ul><p>&nbsp;</p><p><strong>进阶：</strong></p><ul>  <li>如果你已经实现<em> </em><code>O(n)</code> 时间复杂度的解法, 请尝试设计一个 <code>O(n log(n))</code> 时间复杂度的解法。</li> </ul><div><div>Related Topics</div><div><li>数组</li><li>二分查找</li><li>前缀和</li><li>滑动窗口</li></div></div><br><div><li>👍 1652</li><li>👎 0</li></div>[209.长度最小的子数组.md]()<h1 id="思想："><a href="#思想：" class="headerlink" title="思想："></a>思想：</h1><p>本来打算用双指针做，但是我的双指针超时了。</p><h1 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minSubArrayLen</span>(<span class="params">self, target: <span class="built_in">int</span>, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        ans = n+<span class="number">1</span>   <span class="comment"># inf</span></span><br><span class="line">        s = <span class="number">0</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> right, x <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            <span class="comment"># 记录前一次的相加结果</span></span><br><span class="line">            s += x</span><br><span class="line">            <span class="comment"># 移动左端点,left &lt;= right,因为这个数前面的和s已经&gt;=target了，所以从前面的s中减少数字判断是否还能减少</span></span><br><span class="line">            <span class="keyword">while</span> s - nums[left] &gt;= target:</span><br><span class="line">                s -= nums[left]</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> s &gt;= target:</span><br><span class="line">                ans = <span class="built_in">min</span>(ans, right-left+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> ans <span class="keyword">if</span> ans &lt;= n <span class="keyword">else</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目：&quot;&gt;&lt;a href=&quot;#题目：&quot; class=&quot;headerlink&quot; title=&quot;题目：&quot;&gt;&lt;/a&gt;题目：&lt;/h1&gt;&lt;p&gt;给定一个含有&amp;nbsp;&lt;code&gt;n&lt;/code&gt;&lt;strong&gt;&amp;nbsp;&lt;/strong&gt;个正整数的数组和一个正整数 &lt;co</summary>
      
    
    
    
    
    <category term="Python" scheme="https://longsizhuo123.github.io/tags/Python/"/>
    
    <category term="题解" scheme="https://longsizhuo123.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>6351. 标记所有元素后数组的分数</title>
    <link href="https://longsizhuo123.github.io/post/20116270.html"/>
    <id>https://longsizhuo123.github.io/post/20116270.html</id>
    <published>2023-03-19T06:49:00.000Z</published>
    <updated>2023-07-27T08:03:55.610Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h1><p><a href="https://leetcode.cn/problems/find-score-of-an-array-after-marking-all-elements/">6351. 标记所有元素后数组的分数.md</a><br>给你一个数组 nums ，它包含若干正整数。</p><p>一开始分数 score = 0 ，请你按照下面算法求出最后分数：</p><p>从数组中选择最小且没有被标记的整数。如果有相等元素，选择下标最小的一个。<br>将选中的整数加到 score 中。<br>标记 被选中元素，如果有相邻元素，则同时标记 与它相邻的两个元素 。<br>重复此过程直到数组中所有元素都被标记。<br>请你返回执行上述算法后最后的分数。</p><p>示例 1：</p><p>输入：nums = [2,1,3,4,5,2]<br>输出：7<br>解释：我们按照如下步骤标记元素：</p><ul><li>1 是最小未标记元素，所以标记它和相邻两个元素：[2,1,3,4,5,2] 。</li><li>2 是最小未标记元素，所以标记它和左边相邻元素：[2,1,3,4,5,2] 。</li><li>4 是仅剩唯一未标记的元素，所以我们标记它：[2,1,3,4,5,2] 。<br>总得分为 1 + 2 + 4 = 7 。<h1 id="思想："><a href="#思想：" class="headerlink" title="思想："></a>思想：</h1>直接暴力了，然后超时了，不过感觉答案也挺像暴力的。<h1 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h1><figure class="highlight python"><figcaption><span>我流</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findScore</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">set</span>(nums) != &#123;inf&#125;:</span><br><span class="line">            <span class="built_in">print</span>(nums)</span><br><span class="line">            mm = <span class="built_in">min</span>(nums)</span><br><span class="line">            min_index = nums.index(mm)</span><br><span class="line">            grade += mm</span><br><span class="line">            nums[min_index] = inf</span><br><span class="line">            <span class="keyword">if</span> min_index &gt; <span class="number">0</span>:</span><br><span class="line">                nums[min_index - <span class="number">1</span>] = inf</span><br><span class="line">            <span class="keyword">if</span> min_index &lt; <span class="built_in">len</span>(nums) - <span class="number">1</span>:</span><br><span class="line">                nums[min_index + <span class="number">1</span>] = inf</span><br><span class="line">        <span class="keyword">return</span> grade</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight python"><figcaption><span>灵神的排序</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findScore</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        vis = [<span class="literal">False</span>] * (<span class="built_in">len</span>(nums) + <span class="number">2</span>)  <span class="comment"># 保证下标不越界</span></span><br><span class="line">        <span class="keyword">for</span> i, x <span class="keyword">in</span> <span class="built_in">sorted</span>(<span class="built_in">enumerate</span>(nums, <span class="number">1</span>), key=<span class="keyword">lambda</span> p: p[<span class="number">1</span>]):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> vis[i]:</span><br><span class="line">                vis[i - <span class="number">1</span>] = <span class="literal">True</span></span><br><span class="line">                vis[i + <span class="number">1</span>] = <span class="literal">True</span>  <span class="comment"># 标记相邻的两个元素</span></span><br><span class="line">                ans += x</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目：&quot;&gt;&lt;a href=&quot;#题目：&quot; class=&quot;headerlink&quot; title=&quot;题目：&quot;&gt;&lt;/a&gt;题目：&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/find-score-of-an-array-after</summary>
      
    
    
    
    
    <category term="Python" scheme="https://longsizhuo123.github.io/tags/Python/"/>
    
    <category term="题解" scheme="https://longsizhuo123.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>6324. 最大化数组的伟大值</title>
    <link href="https://longsizhuo123.github.io/post/1e6b72b8.html"/>
    <id>https://longsizhuo123.github.io/post/1e6b72b8.html</id>
    <published>2023-03-19T06:42:00.000Z</published>
    <updated>2023-07-27T08:03:55.610Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h1><p><a href="https://leetcode.cn/problems/maximize-greatness-of-an-array/">6324. 最大化数组的伟大值.md</a><br>给你一个下标从 0 开始的整数数组 nums 。你需要将 nums 重新排列成一个新的数组 perm 。</p><p>定义 nums 的 伟大值 为满足 0 &lt;= i &lt; nums.length 且 perm[i] &gt; nums[i] 的下标数目。</p><p>请你返回重新排列 nums 后的 最大 伟大值。</p><p>示例 1：</p><p>输入：nums = [1,3,5,2,1,3,1]<br>输出：4<br>解释：一个最优安排方案为 perm = [2,5,1,3,3,1,1] 。<br>在下标为 0, 1, 3 和 4 处，都有 perm[i] &gt; nums[i] 。因此我们返回 4 。</p><h1 id="思想："><a href="#思想：" class="headerlink" title="思想："></a>思想：</h1><p>这道题想了三种方法：<br>    首先是田忌赛马（我流）： 我把nums不断地重排，把数字提前，然后对比（超时）<br>    然后是双指针-哈希表：<br>        每个元素只能被大的元素指向一次（比如5比3大，3就不能再跟4对比了）<br>        两个指针同时指向尾元素，当left 不小于 right的时候，left–。<br>        else left– right–  Counter– count ++<br>        最后返回count<br>    灵神的田忌赛马：<br>        sort后直接在原数组上面找比当前元素大的元素</p><h1 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h1><figure class="highlight python"><figcaption><span>我流</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maximizeGreatness</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        nums.sort()</span><br><span class="line">        nums_source.sort()</span><br><span class="line">        max_count = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 当新数组与旧数组相同时，停止循环</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">             nums_source = nums_source[<span class="number">1</span>:] + [nums_source[<span class="number">0</span>]]</span><br><span class="line">             <span class="built_in">print</span>(nums_source, nums)</span><br><span class="line">             count = <span class="number">0</span></span><br><span class="line">             <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">                 <span class="keyword">if</span> nums_source[i] &gt; nums[i]:</span><br><span class="line">                     count += <span class="number">1</span></span><br><span class="line">                     <span class="built_in">print</span>(count)</span><br><span class="line">             max_count = <span class="built_in">max</span>(max_count, count)</span><br><span class="line">        <span class="keyword">return</span> max_count</span><br></pre></td></tr></table></figure><figure class="highlight python"><figcaption><span>双指针+哈希表</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maximizeGreatness</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="comment">#print(nums)</span></span><br><span class="line">        left = <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        dicts = Counter(nums)</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        right = left</span><br><span class="line">        <span class="keyword">while</span> right &gt;= left &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> nums[right] &lt;= nums[left]:</span><br><span class="line">                left -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> nums[right] &gt; nums[left]:</span><br><span class="line">                <span class="keyword">if</span> dicts[nums[left]] &gt; <span class="number">0</span>:</span><br><span class="line">                    dicts[nums[left]] -= <span class="number">1</span></span><br><span class="line">                    left -= <span class="number">1</span></span><br><span class="line">                    right -= <span class="number">1</span></span><br><span class="line">                    count += <span class="number">1</span></span><br><span class="line">                    <span class="comment">#print(dicts, nums, count)</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    left -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> right == <span class="number">0</span> <span class="keyword">or</span> left == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure><figure class="highlight python"><figcaption><span>田忌赛马</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maximizeGreatness</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        nums.sort()</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> x &gt; nums[i]:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> i</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目：&quot;&gt;&lt;a href=&quot;#题目：&quot; class=&quot;headerlink&quot; title=&quot;题目：&quot;&gt;&lt;/a&gt;题目：&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/maximize-greatness-of-an-arr</summary>
      
    
    
    
    
    <category term="Python" scheme="https://longsizhuo123.github.io/tags/Python/"/>
    
    <category term="题解" scheme="https://longsizhuo123.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>6323. 将钱分给最多的儿童</title>
    <link href="https://longsizhuo123.github.io/post/b9130c0e.html"/>
    <id>https://longsizhuo123.github.io/post/b9130c0e.html</id>
    <published>2023-03-19T05:51:00.000Z</published>
    <updated>2023-07-27T08:03:55.610Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h1><p><a href="https://leetcode.cn/problems/distribute-money-to-maximum-children/">6323. 将钱分给最多的儿童.md</a><br>给你一个整数 money ，表示你总共有的钱数（单位为美元）和另一个整数 children ，表示你要将钱分配给多少个儿童。</p><p>你需要按照如下规则分配：</p><p>所有的钱都必须被分配。<br>每个儿童至少获得 1 美元。<br>没有人获得 4 美元。<br>请你按照上述规则分配金钱，并返回 最多 有多少个儿童获得 恰好 8 美元。如果没有任何分配方案，返回 -1 。</p><p>示例 1：</p><p>输入：money = 20, children = 3<br>输出：1<br>解释：<br>最多获得 8 美元的儿童数为 1 。一种分配方案为：</p><ul><li>给第一个儿童分配 8 美元。</li><li>给第二个儿童分配 9 美元。</li><li>给第三个儿童分配 3 美元。<br>没有分配方案能让获得 8 美元的儿童数超过 1 。<h1 id="思想："><a href="#思想：" class="headerlink" title="思想："></a>思想：</h1>一开始就发现了这个是数学题，奈何写了半天不知道怎么处理最后剩下的钱。<br>于是写了一个列表，一个孩子一个孩子地给钱。<br>数学：<br>如果剩余 0 人，且 money&gt;0，那么必须分给一个已经分到 8 美元的人，<br>ans 减一。<br>如果剩余 1 人，且 money=3，为避免分配 4 美元，<br>那么必须分给一个已经分到 8 美元的人，ans 减一。<br>其它情况全部给一个人，如果这个人分配到 4 美元，<br>他再给另一个人 1 美元，这样 ans 不变。<h1 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h1><figure class="highlight python"><figcaption><span>列表</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">distMoney</span>(<span class="params">self, money: <span class="built_in">int</span>, children: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        money -= children</span><br><span class="line">        children_list = [<span class="number">1</span>] * children</span><br><span class="line">        <span class="keyword">if</span> money &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        counts = <span class="built_in">min</span>(money // <span class="number">7</span>, children)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(counts):</span><br><span class="line">            children_list[i] = <span class="number">8</span></span><br><span class="line">        children_list[-<span class="number">1</span>] += money - counts * <span class="number">7</span></span><br><span class="line">        counts = children_list.count(<span class="number">8</span>)</span><br><span class="line">        <span class="keyword">if</span> children_list[-<span class="number">1</span>] == <span class="number">4</span>:</span><br><span class="line">            <span class="keyword">if</span> children_list[-<span class="number">2</span>] != <span class="number">8</span>:</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                counts -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> counts</span><br></pre></td></tr></table></figure><figure class="highlight python"><figcaption><span>数学</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">distMoney</span>(<span class="params">self, money: <span class="built_in">int</span>, children: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        money -= children  <span class="comment"># 每人至少 1 美元</span></span><br><span class="line">        <span class="keyword">if</span> money &lt; <span class="number">0</span>: <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        ans = <span class="built_in">min</span>(money // <span class="number">7</span>, children)  <span class="comment"># 初步分配，让尽量多的人分到 8 美元</span></span><br><span class="line">        money -= ans * <span class="number">7</span></span><br><span class="line">        children -= ans</span><br><span class="line">        <span class="comment"># children == 0 and money：必须找一个前面分了 8 美元的人，分配完剩余的钱</span></span><br><span class="line">        <span class="comment"># children == 1 and money == 3：不能有人恰好分到 4 美元</span></span><br><span class="line">        <span class="keyword">if</span> children == <span class="number">0</span> <span class="keyword">and</span> money <span class="keyword">or</span> \</span><br><span class="line">           children == <span class="number">1</span> <span class="keyword">and</span> money == <span class="number">3</span>:</span><br><span class="line">            ans -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目：&quot;&gt;&lt;a href=&quot;#题目：&quot; class=&quot;headerlink&quot; title=&quot;题目：&quot;&gt;&lt;/a&gt;题目：&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/distribute-money-to-maximum-</summary>
      
    
    
    
    
    <category term="Python" scheme="https://longsizhuo123.github.io/tags/Python/"/>
    
    <category term="题解" scheme="https://longsizhuo123.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>2341. 数组能形成多少数对  每日一题</title>
    <link href="https://longsizhuo123.github.io/post/f953c753.html"/>
    <id>https://longsizhuo123.github.io/post/f953c753.html</id>
    <published>2023-03-12T13:49:00.000Z</published>
    <updated>2023-07-27T08:03:55.609Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h1><p><img src="../assets/img/2023-02-16.png" alt="2023-02-16.png"><br><a href="https://leetcode.cn/problems/maximum-number-of-pairs-in-array/description/">2341. 数组能形成多少数对.md</a></p><h1 id="思想："><a href="#思想：" class="headerlink" title="思想："></a>思想：</h1><h2 id="我流："><a href="#我流：" class="headerlink" title="我流："></a>我流：</h2><p>不知道是不是看到“简单”两个字，这道题有主动思考最优解。居然这一次比ylb大佬的哈希表方法还快。<br>把列表排序后，两个两个看是否相等就行。</p><h2 id="哈希表思想："><a href="#哈希表思想：" class="headerlink" title="哈希表思想："></a>哈希表思想：</h2><p>Counter计数后，<code>a+=v//2</code>,<code>b+=v%2</code>对于每个数字 x，<br>如果 x 出现的次数 v 大于 1，则可以从数组中选出两个 x 形成一个数对，我们将v 除以 2 向下取整，<br>即可得到当前数字 x 可以形成的数对数目，然后我们累加这个数目到变量 s 中。</p><h1 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h1><figure class="highlight python"><figcaption><span>普通计数</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numberOfPairs</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        nums.sort()</span><br><span class="line">        ans = [<span class="number">0</span>, <span class="built_in">len</span>(nums)]</span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[index - <span class="number">1</span>] == nums[index]:</span><br><span class="line">                ans[<span class="number">0</span>] += <span class="number">1</span></span><br><span class="line">                ans[<span class="number">1</span>] -= <span class="number">2</span></span><br><span class="line">                nums[index - <span class="number">1</span>] = nums[index] = -<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><figure class="highlight python"><figcaption><span>哈希表</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numberOfPairs</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        x = Counter(nums)</span><br><span class="line">        a = <span class="number">0</span></span><br><span class="line">        b = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> k,v <span class="keyword">in</span> x.items():</span><br><span class="line">            a+=v//<span class="number">2</span></span><br><span class="line">            b+=v%<span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> [a,b]</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目：&quot;&gt;&lt;a href=&quot;#题目：&quot; class=&quot;headerlink&quot; title=&quot;题目：&quot;&gt;&lt;/a&gt;题目：&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;../assets/img/2023-02-16.png&quot; alt=&quot;2023-02-16.png&quot;&gt;&lt;br&gt;&lt;</summary>
      
    
    
    
    
    <category term="Python" scheme="https://longsizhuo123.github.io/tags/Python/"/>
    
    <category term="题解" scheme="https://longsizhuo123.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>math</title>
    <link href="https://longsizhuo123.github.io/post/a927044d.html"/>
    <id>https://longsizhuo123.github.io/post/a927044d.html</id>
    <published>2023-03-12T13:49:00.000Z</published>
    <updated>2023-07-27T08:03:55.618Z</updated>
    
    <content type="html"><![CDATA[<p>如 $\lim_{x \to 0} \frac{\sin x}{x}$ 渲染的是</p><p>$$<br>\begin{eqnarray}<br> \lim_{x \to 0} \frac{\sin x + x^2 + x^3}{x} &amp; = &amp; \lim_{x \to 0} \frac{\sin x }{x} + \lim_{x \to 0} \frac{x^2 }{x} + \lim_{x \to 0}\frac{x^3}{x}<br>\\ &amp; = &amp; \lim_{x \to 0}\frac{\sin x}{x}<br>\\ &amp; = &amp; 1<br>\end{eqnarray}<br>$$</p><span id="more"></span><p>斐波那契数列$A_n=A_{n-1}+A_{n-2}$,前后两项的比值逐渐收敛到黄金分割比例<br>$$\lim_{n\to \infty}\frac{A_{n-1}}{A_n}=\frac{\sqrt{5}-1}{2}.$$</p><p>因式分解<br>$$\begin{split}(x−1)(x−3)&amp;=x^2−4x+3 \<br>&amp;=x^2−4x+4−1 \<br>&amp;=(x−2)^2−1<br>\end{split}<br>$$</p><p>狄利克雷函数</p><p>$$<br>D(x)=<br>\begin{cases}<br>1,&amp; x \in Q \<br>0,&amp; x \notin Q<br>\end{cases}<br>$$</p><p>高斯公式<br>$$<br>\iiint_{\Omega}\left(\frac{\partial P}{\partial x}+\frac{\partial Q}{\partial y}+\frac{\partial R}{\partial z}\right) d v=\iint_{\Sigma} P d y d z+Q d z d x+R d x d y<br>$$</p><h2 id="物理公式"><a href="#物理公式" class="headerlink" title="物理公式"></a>物理公式</h2><ul><li>牛顿第一定律: $\sum \vec{F}_{i}=\frac{\mathrm{d} \vec{v}}{\mathrm{d} t}=0$</li><li>牛顿第二定律: $\vec{F}=\frac{\mathrm{d} m}{\mathrm{d} t} \vec{v}+m \frac{\mathrm{d} \vec{v}}{\mathrm{d} t}=\frac{\mathrm{d} m}{\mathrm{d} t} \vec{v}+m \vec{a}=\frac{\mathrm{d} m}{\mathrm{d} t} \vec{v}+m \frac{\mathrm{d}^{2} \vec{r}}{\mathrm{d} t^{2}}$</li><li>牛顿第三定律: $\overrightarrow{F_{12}}=-\overrightarrow{F_{21}}$</li><li>质能守恒: $E=mc^2$</li></ul><h2 id="化学公式"><a href="#化学公式" class="headerlink" title="化学公式"></a>化学公式</h2><p>离子反应与沉淀: $\ce{SO4^2- + Ba^2+ -&gt; BaSO4 v}$</p><h2 id="生物公式"><a href="#生物公式" class="headerlink" title="生物公式"></a>生物公式</h2><p>光合作用<br>范德蒙行列式<br>$$D_{n-1}=\left|\begin{array}{cccc}<br>1 &amp; 1 &amp; \dots &amp; 1 \<br>x_{2} &amp; x_{3} &amp; \dots &amp; x_{n} \<br>\vdots &amp; \vdots &amp; &amp; \vdots \<br>x_{2}^{n-2} &amp; x_{3}^{n-2} &amp; \dots &amp; x_{n}^{n-2}<br>\end{array}\right|=\prod_{2 \leq j&lt;i \leq n}\left(x_{i}-x_{j}\right)$$</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;如 $\lim_{x \to 0} \frac{\sin x}{x}$ 渲染的是&lt;/p&gt;
&lt;p&gt;$$&lt;br&gt;\begin{eqnarray}&lt;br&gt; \lim_{x \to 0} \frac{\sin x + x^2 + x^3}{x} &amp;amp; = &amp;amp; \lim_{x \to 0} \frac{\sin x }{x} + \lim_{x \to 0} \frac{x^2 }{x} + \lim_{x \to 0}\frac{x^3}{x}&lt;br&gt;\\ &amp;amp; = &amp;amp; \lim_{x \to 0}\frac{\sin x}{x}&lt;br&gt;\\ &amp;amp; = &amp;amp; 1&lt;br&gt;\end{eqnarray}&lt;br&gt;$$&lt;/p&gt;</summary>
    
    
    
    <category term="math" scheme="https://longsizhuo123.github.io/categories/math/"/>
    
    
    <category term="math" scheme="https://longsizhuo123.github.io/tags/math/"/>
    
  </entry>
  
</feed>
